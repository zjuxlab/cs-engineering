<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-basics/design/design-intro" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">设计模式概述 | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-test-site.com/cs-engineering/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-test-site.com/cs-engineering/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/cs-engineering/docs/basics/design/design-intro"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="设计模式概述 | My Site"><meta data-rh="true" name="description" content="- 文章有很大一部分参考了 https://refactoring.guru/"><meta data-rh="true" property="og:description" content="- 文章有很大一部分参考了 https://refactoring.guru/"><link data-rh="true" rel="icon" href="/cs-engineering/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/cs-engineering/docs/basics/design/design-intro"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/cs-engineering/docs/basics/design/design-intro" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/cs-engineering/docs/basics/design/design-intro" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/cs-engineering/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/cs-engineering/blog/atom.xml" title="My Site Atom Feed"><link rel="stylesheet" href="/cs-engineering/assets/css/styles.e7581bb8.css">
<link rel="preload" href="/cs-engineering/assets/js/runtime~main.363a3de4.js" as="script">
<link rel="preload" href="/cs-engineering/assets/js/main.8268da69.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/cs-engineering/"><div class="navbar__logo"><img src="/cs-engineering/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/cs-engineering/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/cs-engineering/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/cs-engineering/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cs-engineering/docs/intro">Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cs-engineering/docs/category/前端">前端</a><button aria-label="Toggle the collapsible sidebar category &#x27;前端&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cs-engineering/docs/category/后端">后端</a><button aria-label="Toggle the collapsible sidebar category &#x27;后端&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/cs-engineering/docs/category/基础">基础</a><button aria-label="Toggle the collapsible sidebar category &#x27;基础&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/cs-engineering/docs/category/设计模式">设计模式</a><button aria-label="Toggle the collapsible sidebar category &#x27;设计模式&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/cs-engineering/docs/basics/design/design-intro">设计模式概述</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/docs/category/linux">Linux</a><button aria-label="Toggle the collapsible sidebar category &#x27;Linux&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/docs/category/网络">网络</a><button aria-label="Toggle the collapsible sidebar category &#x27;网络&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/docs/category/代码规范">代码规范</a><button aria-label="Toggle the collapsible sidebar category &#x27;代码规范&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/docs/category/虚拟化">虚拟化</a><button aria-label="Toggle the collapsible sidebar category &#x27;虚拟化&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cs-engineering/docs/category/工具">工具</a><button aria-label="Toggle the collapsible sidebar category &#x27;工具&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/cs-engineering/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/cs-engineering/docs/category/基础"><span itemprop="name">基础</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/cs-engineering/docs/category/设计模式"><span itemprop="name">设计模式</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">设计模式概述</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>设计模式概述</h1><ul><li>文章有很大一部分参考了 <a href="https://refactoring.guru/" target="_blank" rel="noopener noreferrer">https://refactoring.guru/</a> </li><li><strong>不过不建议通过这个网站进行设计模式的学习</strong>。可能是为了给设计模式进行准确定义，其内容经常比较抽象，让人难以了解到模式的目的。并且它在介绍时还顺便介绍了很多变体和综合，常常让读者觉得毫无重点，有点强行分类和定义。<strong>但是可以当作目录使用。</strong></li><li>比较建议的学习方式是去 StackOverflow 上询问实际场景</li><li>您可以先了解一下 <a href="https://cloud.tencent.com/developer/article/1684161" target="_blank" rel="noopener noreferrer">UML 图</a> 的常用图标含义</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="clean-code">Clean Code<a href="#clean-code" class="hash-link" aria-label="Direct link to Clean Code" title="Direct link to Clean Code">​</a></h2><p><strong>在进行“设计”之前，首先应该明确设计的目的。</strong></p><p>一切关于代码结构，代码功能的研究和准则，无非是为了让代码更加适应开发需求，或者说，更加 <strong>&quot;Clean&quot;.</strong> Clean code 是一个非常主观，复杂且多方面的定义，但是在继续了解 design pattern 时，不妨将其归结为以下几点：</p><ol><li><strong>Obvious</strong><ol><li>清晰易读，逻辑明确的代码</li></ol></li><li><strong>No duplicate</strong><ol><li>没有不必要的重复</li></ol></li><li><strong>Accept change</strong><ol><li>接受一定的修改和扩展</li></ol></li><li><strong>Pass all test</strong><ol><li>当然，好的代码必须（至少看起来）工作良好x</li></ol></li></ol><blockquote><p>关于更多 clean code 的内容，可以参考 <a href="https://xn4zlkzg4p.feishu.cn/wiki/wikcn4Dkcyyu5KfA5R0MgYP8y6f" target="_blank" rel="noopener noreferrer">《Clean Code》阅读与总结</a>  </p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="refactoring">Refactoring<a href="#refactoring" class="hash-link" aria-label="Direct link to Refactoring" title="Direct link to Refactoring">​</a></h2><blockquote><p>抛开实际语言和代码的重构讨论将会逐渐变成抽象的哲学</p><p>这不是我们希望看到的</p><p>所以这部分讨论将尽量局限于可以比较没有争议，可以作为 COC 的内容</p></blockquote><p>Clean code 看起来非常简单而愉快，但是让自己的代码变得 &quot;clean&quot; 并不如想象中的容易。</p><p>人们在编写代码时往往是盲目且懒惰的，为了修正丑陋的代码，将会对代码进行<strong>重构</strong>。</p><p><strong>之所以在讨论设计模式前先讨论重构，是因为重构的目标很直接地指向了 clean code 的标准，而之后的设计模式无论再复杂，其核心目标和简单的重构是差不多的。</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="简单直观的重构">简单直观的重构<a href="#简单直观的重构" class="hash-link" aria-label="Direct link to 简单直观的重构" title="Direct link to 简单直观的重构">​</a></h3><p>Clean code 的准则定义得十分模糊，我们很难对着一份代码争辩它是否 &quot;accept changes&quot;。好在，不好的代码会产生一些明显的特征，我们称之为 <strong>&quot;Bad Smell&quot;.</strong></p><p>通过直观的 bad smell 可以让我们发现代码的深层缺陷。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="improper-name">Improper Name<a href="#improper-name" class="hash-link" aria-label="Direct link to Improper Name" title="Direct link to Improper Name">​</a></h4><p><strong>不恰当的命名</strong> 是最常见的 bad smell。我们先抛开那些因为偷懒而产生的命名失当，命名不恰当侧面反应了这段代码难以被命名。</p><p>比如，当一段代码过长，逻辑过于复杂时，我们就很难为其命名，同理，过于膨胀的类也会难以命名。我们会发现这些差劲的名字要么不能概括其功能，要么里面充斥了一名词，明显是由很多个句子组成。这种情况我们一般称为 <strong>Bloater.</strong></p><p>而解决这个问题的重构方法也很简单，概括为一个字就是“拆”，将长函数分隔为短函数，将巨大的类分为几个小类。遇到复杂的条件句，就将其拆成一个 checker 函数，发现纠缠不清的变量，就用一个 query 函数来替代它。</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># before</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def BigFunc():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # logic about variable qwq</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if a &gt; 100 or b &lt; 1000:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return qwq</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#   ⇩⇩⇩   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#  refactoring</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#   ⇩⇩⇩   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># after       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def func():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dosomething()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if checkRangeOfAB(a,b):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return queryQwQ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def dosomething():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>借此，我们能将庞大交错的逻辑区分的清晰明了。同时，你会发现很多情况下，过度膨胀的代码包含了许多重复的部分，重构也是在解决 duplicate 的问题。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="primitive-obsession">Primitive Obsession<a href="#primitive-obsession" class="hash-link" aria-label="Direct link to Primitive Obsession" title="Direct link to Primitive Obsession">​</a></h4><p>除了命名造成的困扰，大量变量同样会造成代码易读性下降，想象一下使用下面这个类：</p><p>(感觉 python 因为动态类型不好举例，换成了 C#)</p><div class="language-C# codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C# codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Person</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string ID {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string Name {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string Address {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string PostCode {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string Country {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string City {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>虽然已经进行了小小的分段，使得代码好看了许多，但是这么多变量还是非常抽象的。而且，它们都是 &quot;primitive type&quot; 的变量，也就是说，其类型的含义不足以表达变量的意义。</p><p>在上面这个例子中，我甚至不想给出它的构造函数（懒）。想象一下，这个构造函数将是一长串 <code>string</code> 变量，在不断重复调用它的过程中，大概率会有一次会把 <code>city</code> 和 <code>country</code> 字段写反！</p><p>因此，我们要将 primitive 包装成新的结构体（我们姑且先称结构体，因为这里还不想提及它们作为 “类” 的特点），一方面，这样<strong>强化了 primitive 的意义</strong>，另一方面，这样使得 primitive 有了<strong>类型安全</strong>性：</p><div class="language-C# codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C# codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Person</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Person(string Name, Address adress)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // init</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public PersonID ID {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string Name {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Address Address {get;set;} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// strong-type &amp; read-only id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public readonly struct PersonID : IComparable&lt;PersonID&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IEquatable&lt;PersionID&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string ID {get;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // overload equals compare new .....,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Address class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Address</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Address(string detailAddress)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // parse</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string Address {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string PostCode {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string Country {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public string City {get;set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="comments-are-bad">Comments are bad<a href="#comments-are-bad" class="hash-link" aria-label="Direct link to Comments are bad" title="Direct link to Comments are bad">​</a></h4><p>写代码加注释常常被认为是一个好习惯，但是在某种意义上，注释其实是坏文明！</p><p>注释的作用是对代码进行解释，但是，除了一些对复杂算法进行来源注明的注释，或者对于一些特定的怪异操作进行解释的注释，剩下的注释其实是不必要的。反而，依赖注释会使得代码本身正确命名和分块的需求减小，会<strong>掩饰代码的 bad smell</strong>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="考虑-代码结构">考虑 “代码结构”<a href="#考虑-代码结构" class="hash-link" aria-label="Direct link to 考虑 “代码结构”" title="Direct link to 考虑 “代码结构”">​</a></h3><p>在直观的 bad smell 的引导下，上述的重构方法应该能快速地改造代码。</p><p>但是，在不断抽离方法后和结构体后，代码会被它们塞满。这些方法应该放在哪？如何将一个简单提取的结构体变成一个设计良好的类？这是应该进一步考虑的事情。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="extract-class">Extract class<a href="#extract-class" class="hash-link" aria-label="Direct link to Extract class" title="Direct link to Extract class">​</a></h4><p>从开始考虑如何构建一个类，如何考虑类的关系起，我们就已经进入了 oop 的领域。</p><p>经过之前的重构，将处理一类数据的 “过程” 提取为 “类” 其实是非常自然的事情。</p><p>一个思路是从 <strong>data clump</strong> 开始，首先将绑定的数据块封装进一个 struct 中，然后通过寻找和这些数据有关的函数，将它们重构为类的方法。</p><p>典型的例子是 <strong>Introduce Parameter Object，</strong>这是一种简化超长参数列表的重构方法。这种方法就是先将参数列表封装进一个类中，然后再将使用这个参数列表的函数，和一些预处理出参数的过程封装进类中，就能得到一个比较完善的类。</p><p>另一条路是从 <strong>method object</strong> 入手，首先从代码逻辑考虑，分离出若干函数，然后再寻找其共同的依赖变量，将这些变量封装成一个类。当重构的 &quot;long method&quot; 局部变量比较混乱时，直接抽离出函数会耗费很多精力传入重复的参数，这种提取类的方法就会比较好用。</p><p>我们希望提取的类职责尽量单一，所以在经过简单的 extract class 后，可能还需要进一步抽离类来分离职责。</p><blockquote><p>参考后文的 <a href="https://xn4zlkzg4p.feishu.cn/docx/Kf2Gd8GcTob1iUxiw2ScwN0anGh#TYaedyic0owkksxJNYjcysYjndI" target="_blank" rel="noopener noreferrer">SRP</a></p></blockquote><p>出现正交的扩展方向，是一个类有多个职责的信号。</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=OTE4MTA5ZjA3MzNjNjdiMDA5MmM5NWJmZjM0NGY4NDNfQ1c5bU41aW1PMmFaaDJiQVBnTGFqaXYxVEQzTUFlbW5fVG9rZW46Ym94Y245OHdMSUoxMUU1M0JvVXFzRWRRTjlnXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p>例如上图中的 shape 和 color 明显是两个不同维度的扩展，如果两者在同一类中扩展，任一方向的扩展都将影响到另一个方向。故将两者抽离才是正确的选择：</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjMwMDVhYTVkZDc1NTE2YzE3MDJjMmMwMzE0OTc5ODVfOFRENGk4S3BSV2lOZTZBelh4U1Rmd0NGUTByUEhKNEpfVG9rZW46Ym94Y251MXluZ01RNGV2TTBZZ0I1anU4UGJmXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p>这种将一部分功能委托给另一个类的做法称为 <strong>delegation。</strong></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="change-preventer">Change Preventer<a href="#change-preventer" class="hash-link" aria-label="Direct link to Change Preventer" title="Direct link to Change Preventer">​</a></h4><p>我们最后从 <strong>accept changes</strong> 的角度来考虑 bad smell.</p><p>《clean code》给出了两种 <strong>change preventer</strong>：</p><ul><li>Divergent change<ul><li>这个词是相对于一个正在维护的类而言的，形容如何无关的 外部/内部 修改都会迫使该类进行修改。</li><li>对内部修改来说，这可能是因为内部职责混杂</li><li>对外部修改来说，这可能是因为该类外部依赖过多</li><li>可以被称之为 <strong>“high coupling”</strong></li></ul></li><li>Shotgun surgery<ul><li>“散弹式修改”，形容修改任何一个功能都要在代码的各处做修改</li><li>可以被称之为 <strong>“low cohesion”</strong></li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="something-deeper">Something Deeper<a href="#something-deeper" class="hash-link" aria-label="Direct link to Something Deeper" title="Direct link to Something Deeper">​</a></h3><p>上面的重构会引起一些难以直接解决的问题。</p><p>比如在经过一次封装后，我们发现其中一个类内成员频繁地被另一个类使用，这可能意味着目前这个成员的位置是错误的。再比如，有一些子类几乎没有用到它们父类的成员，这说明目前的继承结构是不合理的。</p><p>还有一些 <strong>oop abuse</strong> 的问题。比如不关注对象内数据的 accessibility ，或者使用一个 <strong>big switch</strong> 来代替多态的 <strong>dynamic dispatch</strong>。</p><blockquote><p>所以说 golang 判断 type 的 switch 语句的语法糖简直是败笔中的败笔（个人观点）</p></blockquote><p>可以发现，当我们讨论的 bad smell 越发抽象，越发涉及到代码结构，涉及到 oop 时，直观的重构似乎已经不起作用，必须深入对于代码结构设计的讨论。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="ood-principle">OOD Principle<a href="#ood-principle" class="hash-link" aria-label="Direct link to OOD Principle" title="Direct link to OOD Principle">​</a></h2><blockquote><p>OOD 即面向对象的设计。</p></blockquote><p>我们经验性地提出几个原则，作为设计模式的准则。</p><p>其中除了 Least Know Principle 以外的五个常被称为 <strong>“SOLID” 原则。</strong></p><p>虽然称为原则，它们其实是经验性的批判标准。在之后的设计模式中，多少违反这些原则的例子也并不少，切不可将这些条例当作教条。但是在设计代码时，应该经常思考违反它们可能对代码产生的影响。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dependency-inversion">Dependency Inversion<a href="#dependency-inversion" class="hash-link" aria-label="Direct link to Dependency Inversion" title="Direct link to Dependency Inversion">​</a></h3><p>依赖倒置原则认为，一个分层的依赖结构，高层部分不应依赖低层部分的模块。而应该对低层模块进行抽象，高层系统依赖其抽象，低层系统模块也依赖抽象实现。</p><p>如下图所示，左图中， <code>Project</code> 类直接依赖于具体 <code>Developer</code> 类的实现是很丑陋的，如果有新增的 <code>Developer</code> 类型或者其内接口有改动，都会引起上层更改。</p><p>优雅的做法是两者之间通过一个 <code>Developer</code> 接口进行对接，这样两层之间的耦合就大大降低了。</p><p>暂时无法在飞书文档外展示此内容</p><p>原来的结构是上层依赖于下层，往往上层开发要等待下层完成再进行。而新的结构中，上层不再依赖于具体的下层对象，故称依赖“倒置”。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="open-close">Open Close<a href="#open-close" class="hash-link" aria-label="Direct link to Open Close" title="Direct link to Open Close">​</a></h3><p>对扩展开放，对修改关闭。</p><p>开闭原则要求代码提供高扩展性，当需要增加功能时，通过扩展而不是修改原来的类或接口来增加功能。</p><p>不过这里的修改，一般指不修改 public 成员，对private也限制就太过严苛了，而且从 ducktype 角度来说，我们一般也只关心对象对外展现的性质。</p><p>开闭原则其实是进一步强调多使用接口，其建议将整个代码结构建立在接口上。这样当我们需要扩展时，就可以重新实现一个接口，而不是修改原来的类。</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class IEducation(Interface):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def start(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def evaluate(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Course(IEducation):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   def __init__(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       self.classname = &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       self.teachername = &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class VideoCourse(Course):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super().__init__()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.videourl = &quot;&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如上，<code>VideoCourse</code>通过实现接口 <code>IEducation</code>扩展功能。框架逻辑基于接口而非具体的类，新的扩展类不会破坏原有的代码。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="liskov-substitution">Liskov Substitution<a href="#liskov-substitution" class="hash-link" aria-label="Direct link to Liskov Substitution" title="Direct link to Liskov Substitution">​</a></h3><p>所有接受一个父类对象的地方，必须可以（在语义正确性和行为正确性上）无痕接入其子类的对象。</p><p>里氏替换原则严格限制了继承的使用，我们直觉认识的很多继承方式并不能在 oop 中成立。</p><p>最常见的例子就是 “正方形是一类特殊的长方形”。</p><p>我们确实可以很容易地通过继承和 override 实现一个正方形类（这个实现其实违背了开闭原则）。但是，如果我们要求长方形有设置长和宽的能力，正方形类是无法满足的。从这个角度上来看，正方形不能继承长方形类！<strong>我们的继承要求从 “is” 强化成了 “**</strong>act** <strong>exactly like”。</strong></p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Rectangle:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.width = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.height = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def setW(self,w):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.width = w</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def setH(self,h):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.height = h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Square(Rectangle):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def setW(self,w):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.width = w</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.height = w</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def setH(self,h):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.width = h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.height = h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 子类 Square 在这部分逻辑中表现和父类不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def test(x : Rectangle):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.setW(10)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.setH(20)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print x.width</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>那我们该怎么表示上述这种 “A is a special kind of B” 这个关系呢？</p><p>答案是进行更高层的<strong>抽象</strong>。在关于长方形和正方形的例子中，我们要求的功能过于具体了，在这个具体的意义下，要求正方形是长方形的子类本就是不合理的。</p><p>若是两者通过抽象类来关联，就避免了这种具体场景的使用，其关系就变得合理起来了。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="subtyping-is-not-inheritance"><strong>subtyping is NOT inheritance</strong><a href="#subtyping-is-not-inheritance" class="hash-link" aria-label="Direct link to subtyping-is-not-inheritance" title="Direct link to subtyping-is-not-inheritance">​</a></h4><p>继承其实并不是 oop 的必需项。</p><p>继承严格来说只是一种代码 reuse 的方法，只是同时带有了一定的泛化关系。</p><p>里氏替换原则其实就是在限制以代码复用为目的的继承，破坏了类之间的逻辑关系，或者破坏 OOD 的其他原则，从而对整个代码结构产生坏影响（比如经常因为继承被违反的开闭原则，因为违反里氏原则的继承大概率会进行 override ）。</p><p>所以：</p><ul><li>当你尝试用继承来表示关系时，请先思考这两者的抽象层级是否有上下级关系，否则请抽象一个更高层的接口来关联两者。</li><li>当你尝试用继承来复用代码时，也请先考虑其连带的继承关系是否合理，否则请使用组合或者代理来复用代码（这些在 Design Pattern 部分会有详细讲到）。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="single-responsibility">Single Responsibility<a href="#single-responsibility" class="hash-link" aria-label="Direct link to Single Responsibility" title="Direct link to Single Responsibility">​</a></h3><p>类的职责应该尽量“单一”。</p><p>单一职责使得代码清晰分离，易于定位错误和修改功能。</p><p>例如我们要实现一个员工类，同时要实现计算工资的功能。如果我们这样设计：</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Employee:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def work(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def getSalary(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此时，如果工资计算逻辑改变，我们将会到这个类中修改。</p><p>然而，我们其实可以想到，计算工资和工作两个逻辑起始较为分离，如果放在一个类中，将会增加工作和计算工资两个部分的耦合，且这个类也变得更难维护。</p><p>如果我们再实现一个类似于“财务部门”的类，由其计算工资，将会优雅许多：</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Employee:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def work(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class FinancialApartment:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def caculateSalary(self,employee):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因为单一是个较主观的标准，有时这个准则会难以判定。但是这个准则时刻在提醒我们，在开发中不要为一个类增加多个功能，而是新建类来分离这些功能。</p><p>当发现类和其他类间有复杂耦合，或者私有方法过多且繁琐，不易命名（名词过多），就应该思考是否应该拆分职责。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="interface-segregation">Interface Segregation<a href="#interface-segregation" class="hash-link" aria-label="Direct link to Interface Segregation" title="Direct link to Interface Segregation">​</a></h2><p>类似单一职责原则，接口实现也应该尽量简单分明。</p><p>两者区别在于，单一职责原则往往比较直观，只需着眼于当前类。接口隔离往往牵扯到层级关系，既要从下层思考实现该接口的冗余情况，也要考虑到上层代码中是否需要将不同逻辑拆分开。</p><p>譬如要实现餐馆的线上/线下点餐功能，如果这样定义接口：</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ICustomer(Interface):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def order(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def orderOnline(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def pay(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def payOnline(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass        </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个接口就显得冗余且不够抽象。实际使用时，实现该接口的新类会相应变得繁琐，而且会经常出现不能实现一部分接口的类。上层代码与下层代码的耦合程度，也因为不够抽象而提高。</p><p>首先解决抽象的问题，我们可以不关心操作的途径，只抽象出支付和下单方法，具体细节交由实际类实现。在抽象完之后，我们可以再考虑进行职责的拆分，将原接口分为两个：</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class IOrder(Interface):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def order(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class IPayment(Interface):    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def pay(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass       </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>和单一职责原则相似，这个原则的评定也比较主观。</p><p>在上面这个场景中，假设我们想要对线上订单新增评价功能，若不拆分接口，旧的类实现都需要增加新的评价方法，这样看来，接口的拆分确实有减少耦合和冗余的作用。但是若只关注支付和点单两个方法，这个拆分会让人觉得太麻烦。所以拆分粒度还需根据具体情况斟酌。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="least-know">Least Know<a href="#least-know" class="hash-link" aria-label="Direct link to Least Know" title="Direct link to Least Know">​</a></h3><p>一个对象应该和尽可能少的对象有接触。</p><p>严格来说，类 <code>C</code> 中的方法 <code>M</code> 能直接访问的类应该只有：</p><ul><li><code>C</code> 和 <code>C</code> 的成员的类</li><li>传入给 <code>M</code> 的参数的类（能访问的全局变量视作此类）</li></ul><p>换言之，LKP 要求在 <code>M</code> 中能够访问的只有和其“直接接触”的类，通过降低不必要的非直接沟通来降低类之间的耦合。直观来讲就是 “尽量少用 <code>.</code>”。</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class C:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.component = B()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def getName(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return self.component.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class B:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.name = &quot;qwq&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ins_c = C()        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 这是不合理的使用方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print ins_c.component.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 这是合理的方式，即 &quot;tell instead of ask&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print ins_c.getName()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>实际情况下，我们可以用 &quot;tell instead of ask&quot; 的方式来简化代码，将 <code>M</code> 中的需要写在参数类的方法里。</p><p>但是这种做法会在相应参数类里增加相应方法，这些方法可能是多余的，如果为了满足 LKP 产生了很多冗余方法，则应该考虑更改整个结构的设计，比如干脆将需要间接访问的类直接联系到当前方法中</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="design-pattern">Design Pattern<a href="#design-pattern" class="hash-link" aria-label="Direct link to Design Pattern" title="Direct link to Design Pattern">​</a></h2><ul><li>大多数模式的代码示例都可以在 <a href="https://refactoring.guru/design-patterns" target="_blank" rel="noopener noreferrer">refactorign.guru</a> 找到，并且有多种语言的版本</li><li>因为目的是在介绍设计模式，几乎没有提到使用设计模式为代码带来的 <strong>复杂性</strong> 这一缺点</li><li>不要生搬硬套设计模式</li><li>文章将尽量从缘由开始介绍设计模式，希望这能帮助理解</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="structure">Structure<a href="#structure" class="hash-link" aria-label="Direct link to Structure" title="Direct link to Structure">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="use-interface">Use Interface<a href="#use-interface" class="hash-link" aria-label="Direct link to Use Interface" title="Direct link to Use Interface">​</a></h4><p>设计模式将会用一半的时间使人明白 <strong>interface</strong> 的神奇之处。</p><p>类的内部实现对于依赖它的代码来说并不重要，甚至其对外暴露的成员变量也不是很重要，可以使用 getter 和 setter 来替代。client code 只关心它能怎么给依赖传递参数，以及能从依赖得到什么结果。</p><p>也就是说，一个类真正被依赖的是它的方法。因此，使用 interface 来表示依赖就显得非常自然。</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=OWUxOGY4MGFlZDRmMmMxNDRlNWRmNzY1NGYxMTE0MmRfQzN1SEp3NlhzbmNZU3ZaUzA1NmE1TmZ1aEpFcHRaMFJfVG9rZW46Ym94Y25BQUVmdXhwVFhHbFhsYkRVM1E0cGRnXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p>回顾我们之前提到的 <strong>DIP</strong> ，interface 使得上层依赖于一个下层的抽象，几乎将上下层的耦合降至最小。</p><p>如上图的例子，一个导航应用只关心寻路依赖返回的路线，如果以 interface 的形式建立依赖，上下层的耦合就只在接口的形式上，下层可以以各种方式进行扩展，上层开发也可以不关心下层的实现。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="command">Command<a href="#command" class="hash-link" aria-label="Direct link to Command" title="Direct link to Command">​</a></h4><p>有时候上层依赖下层的方式会很麻烦。</p><p>以一个文本编辑器的 GUI 为例，其底层是一个有基础功能的编辑器。 GUI 调用的功能十分复杂，比如剪切功能，它可能需要先调用编辑器移动光标，再调用 pastebin 将选中的内容暂存，再将这部分删除。</p><p>这个 GUI 可能可以通过按钮和快捷键进行剪切，于是这段复杂的调用依赖代码可能会被重复，这意味着调用逻辑被耦合到了 GUI 的代码中。另一方面，当调用逻辑过于复杂时，“调用” 本身变成了对上层 GUI 代码职责的污染。</p><p>命令模式将 “调用” 依赖的过程封装进一个 <code>command</code> 类中。</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=MTE3ZDJjMDdiNTVjODU4Nzg2YzRjMTM0NWNlMzRiYjdfZTQybThEbkV0RVdqMVdyS3VjeFg3cXVHckpDNVlGVVhfVG9rZW46Ym94Y25NbkJrTmR4ckR0MG40RlZzRkw1OERmXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p>你可以想象它实现了一个控制编辑器的 “遥控器”， GUI 将不直接调用依赖，而是通过 “遥控器” 的命令来控制依赖。</p><p>暂时无法在飞书文档外展示此内容</p><p>如上图所示，底层编辑器作为命令的接收方注入到 command 中，命令参数可以作为 command 的成员进行设置，而 command 的 execute 方法就是具体的底层调用逻辑。</p><p>上述流程的依赖方式可以依具体情况调制。</p><p>如果像上述场景一样，command 和 receiver 的依赖比较固定，可以直接将 receiver 定义为 <code>editor</code> 类型。如果 receiver 有扩展需求，那么可以选择定义为接口，由 client code 进行依赖注入，或者实现一个 factory 获得特定 receiver 的 command.</p><p>而 client code 这边也可以选择直接依赖于具体的 command 类。也可以为 command 再抽象一层接口，方便统一对 command 进行操作和实现 factory.</p><blockquote><p> <a href="https://xn4zlkzg4p.feishu.cn/docx/Kf2Gd8GcTob1iUxiw2ScwN0anGh#VcCudk0ysomKCGxAnG4cPq6an8e" target="_blank" rel="noopener noreferrer">Factory</a> 模式见后文</p></blockquote><p>Command 模式有一些非常有趣的应用，因为具体的 command 可以被实例化成单独的对象，我们可以对每一个命令进行操作。比如，在 command 接口上实现一个 <code>undo</code> 方法来进行撤销操作。</p><p>这种应用可以用来实现编辑器的历史功能：</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=MjNiOTY5ZTNkZGI5NTA5M2I2MTk5YTYzNDAyYmRiNThfbG1BTXRScFZNOWxzZmI1YkpwUTBUb084d2l5ZThacWNfVG9rZW46Ym94Y25NdGhzTUNoaVBrRjdqaXdYWUFhWFRiXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="visitor">Visitor<a href="#visitor" class="hash-link" aria-label="Direct link to Visitor" title="Direct link to Visitor">​</a></h4><p>Visitor 是一种牺牲了一定扩展性的设计模式。</p><p><strong>Visitor 模式可以统合难以通过抽象统一接口的依赖。</strong></p><p>举个例子，一支部队拥有很多兵种和一个指挥官，在这里，指挥官就是我们的 client code，而我们需要统一 “士兵” 这个依赖。一般来说，我们会为士兵抽象一个 “进攻” 接口，这样指挥官只需要调用这个接口就能让士兵进攻，不用管这个士兵是步兵还是骑兵。</p><p>但是问题来了，如果这些兵种里不仅有作战的士兵，还有医疗兵等等，他们的功能和作战兵种的差别太大，难以抽象成 “进攻” 这个接口。若是统一成一个更抽象的接口 “行动”，我们又要在给接口传参上下一番功夫，而且这种过于抽象的接口也失去了接口本应有的 “协约” 功效。</p><p>当然，我们还有一个充满 bad smell 的原始做法 —— <strong>big  switch</strong>！既然无法用接口进行抽象，不妨尝试对这种方法进行改进。</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># client code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if isinstance(obj,classA):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">elif isinstance(obj,classB):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # invalid</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们知道，使用接口的好处之一是其 <strong>dynamic dispatch</strong>，即当调用方法时，实际对象会根据自己的类型 &quot;dispatch&quot; 自己所属类型的方法。而我们使用 switch 其实就是在手动进行 dispatch。</p><p>但其实，在使用 switch 时，每个对象还是知道自己的类型的。那么，我们不妨不主动判断其类型，然后分配正确的方法，而是将所有的方法都提供给对象，让对象自己选择正确的调用方法。</p><p>暂时无法在飞书文档外展示此内容</p><p>通过将判断和选择工作委托给类本身，我们实现了一次静态的分配。而通过实现 <code>Visitor</code>接口，我们也能进行方法的扩展。这种结构被称为 <strong>double dispatch.</strong></p><p>上述例子中，<code>Medic</code> <code>Soldier</code>等都是类依赖，我们完全可以将它们都改为接口依赖。如此一来，我们相对于静态分配了几个大类，而每个大类可以通过接口各自实现不同的扩展。</p><p>如果最上层的分类足够稳定，<strong>Visitor 模式还能提供一个比较简化的方法扩展方案。</strong></p><p>我们在扩展方法时，秉着 <strong>OCP</strong> 和 <strong>ISP，</strong>一般来说会新定义一个功能接口，然后定义新类实现这个新接口，将原来的类通过 compose 的方法关联到新类中：</p><blockquote><p>通过继承进行扩展是极其丑陋的行为！</p><p>而且通过继承来扩展产生的全新的扩展对象，要对现有的对象做扩展不如通过 compose 来的方便。</p></blockquote><p>暂时无法在飞书文档外展示此内容</p><p>而在类足够稳定，基本不会进行扩展的情况下，我们可以用 Visitor 实现功能扩展。在实现了 Visitor 模式的基本结构之后，扩展新的 Visitor 是非常方便的。我们只需新实现一个具体的 <code>Visitor</code> 类，从步骤来说比一般的方法简便，而且增加一个功能只需要实现一个类，避免了代码中的类快速增加，变得冗长。</p><blockquote><p><strong>Visitor 模式进行功能扩展的本质原因，是其类似于 Command 模式的调用方法，所以说 Command 模式也能这么扩展功能。</strong></p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="creation"><strong>Creation</strong><a href="#creation" class="hash-link" aria-label="Direct link to creation" title="Direct link to creation">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="factory">Factory<a href="#factory" class="hash-link" aria-label="Direct link to Factory" title="Direct link to Factory">​</a></h4><p>Factory (工厂)，是一种关于创建实例的设计模式。</p><p>一般来说，一个支持 oop 的语言会以与类同名的函数作为一个 constructor，以直接调用 constructor 或者使用 new 的方式来新建实例 。</p><p>但是当我们需要多种创建逻辑时，在 constructor 里增加太多参数和 conditional 是非常不优雅的。这时我们会想要有多个构造方式，一个好办法就是在类中加入几个 static method 作为额外的构造器。这种静态的 creation method 被称作 <strong>Static Creation Method</strong>。</p><p>静态的构造方法有很多优点：</p><ul><li>当有大段逻辑需要在调用 constructor 之前完成时，我们可以将其封装在 static method 中，以免 construor 中有太多构建之外的逻辑。</li><li>其返回值不一定是一个当前类的 instance，你可以返回其 subtype ，这对多态实现很有帮助。</li><li>其不必要真的新建 instance，而是选择复用已有实例，这可以帮助资源密集型应用节省开支。</li><li>其命名可以自定义，所以可以更清晰地表达 constructor 的逻辑。</li></ul><p>我们暂且从这种代替原本 constructor 的方式，回到设计模式意义下的 factory。<strong>Factory 是一种讨论如何创建依赖类的模式，或者说，是一种 “注入” 模式。</strong></p><p>我们尝试从一段代码的重构过程理解 Factory:</p><ol><li>想象在一段 client code 中，有大量对 <code>Product</code> 类的依赖。</li><li>我们试图降低这份代码和 <code>Product</code> 类的耦合程度，一般来说就是实现一个 <code>IProduct</code> 接口，将关于 <code>Product</code> 类的逻辑抽象出来。</li><li>然而，抽象接口虽然解决了大部分 coupling，但是创建实例的部分仍然和 <code>Product</code> 类联系紧密。</li><li>为了解决这个问题，我们可以将所有创建实例的代码提取出来，全部交由一个 static creation method 实现，这样我们的代码与 <code>Product</code> 类就只在这一处耦合了。</li></ol><p>这个 static creation method 就是 Factory 模式的原型，被称为 <strong>Simple Factory</strong>。</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">from abc import ABC,abstractmethod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class IProduct(ABC):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @abstractmethod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def getName(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class ProductA(IProduct):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def getName(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;A&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class ProductB(IProduct):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def getName(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;B&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Client Code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># import ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def factory(name):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if name == &quot;A&quot;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ProductA()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    elif name == &quot;B&quot;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ProductB()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        raise Exception(&quot;Invalid parameter&quot;)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面 Simple Factory 的一个最简单的例子。通过抽象出的 <code>IProduct</code> 接口，可以实现多种 Product，这意味着我们要不断修改 Simple Factory 的 creation method，最终其会被 switch case 充满。</p><p>本着开闭原则中 “尽量不通过修改来增加功能” 的想法，我们尝试寻找一种通过扩展，而非修改来实现增加 Product 类别的模式：</p><ol><li>将这部分 Client Code 封装在一个 <code>Creator</code> 类中</li><li>在这个 <code>Creator</code> 类中创建一个 abstract method 作为 factory method</li><li>对于不同的 Product 类别，比如 <code>ProductA</code> ，创建一个新的 <code>CreatorA</code> 类并继承 <code>Creator</code>。</li><li>补充其 factory method 为创建 <code>ProductA</code> 实例</li><li>其他类别的 Product 同理</li></ol><p>（步骤 3 可以斟酌保留相似的 Product 在同一个 Creator 类中，使用 <code>switch</code> 进行区分）</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># Creator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># import ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Creator(ABC):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def clientCode(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        product = self.createProduct()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @abstractmethod</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def createProduct():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class CreatorA(Creator):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def createProduct():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ProductA()  </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这样我们就能够通过扩展抽象类 <code>Creator</code> 和接口 <code>IProduct</code> 来实现对原结构的无痕扩展。因为将原来的静态函数变成了类的方法，我们称这种模式为 <strong>Factory Method</strong>。</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmE4ZDg4NzBjM2RmZTVkZmRlNTQ4ODQ3YmE5MmYzZmJfMmlucGV3eWNPSUlZYTd3Y3lMQ29hWjdCdFcxV0dBQkNfVG9rZW46Ym94Y25lQWUzdUd3dWZnYzdCMmhacEhSSlllXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p>Factory method 确实解决了扩展能力的问题，在仅有少数增加的种类时(比如第三方库留给用户的扩展功能)，其表现非常好。</p><p>但是当依赖项的种类逐渐增加，甚至出现多个正交的依赖项种类同时增加时，新的 Creator 子类就会指数级增加，代码仍然会变得十分复杂。这是 Factory 模式不可避免的问题。</p><blockquote><p>之前 <a href="https://xn4zlkzg4p.feishu.cn/docx/Kf2Gd8GcTob1iUxiw2ScwN0anGh#VAimdWooio2qKCxMnhpcgairnmf" target="_blank" rel="noopener noreferrer">Extrac Class</a> 提出，将正交的扩展方向分出一个作为依赖</p><p>但是如果使用 factory 模式，依赖的注入也会通过继承来实现，相当于把皮球又踢了回来</p></blockquote><p>暂且放下这个不可避免的难题不谈，在平行依赖项增加时，自然 Creator 中的 factory method 也会增加，当注入项过多时，注入这一步本身也变得麻烦了。</p><p>从单一职责原则的角度考虑，Creator 应该主要负责 Client Code 部分的逻辑，注入可以算作额外的工作，所以我们要想办法将其分离出去。</p><ul><li>为此，我们可以将所有的 factory method 提取成一个 <code>IFactory</code> 接口，通过实现各个 factory method 来组成一个实现该接口的 <code>Factory</code> 类。</li><li>得益于这个接口的统一，原来多个抽象 Product 依赖变成了一个抽象 Factory 依赖。</li><li>这个 Factory 就类似于原来 Factory Method 中的 Product 。我们的 Creator 类就不需要那么多 factory method，只需要一个生产 “factory” 的 factory method 就够了。</li></ul><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTc5NGI2NmUwYzk0YTNkNWJhYzY5MzgwZGY2ODU2OTZfaDM2bXdtb1d5MXFMZEtaQk1GTWZKUDZFblpCZnh5djhfVG9rZW46Ym94Y242MlNMSWFoUmhKdlVQdEoyOW1BZ1hlXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p>这便是所谓的 <strong>Abstract Factory</strong> 模式。</p><blockquote><p>虽然 refactoring.guru 中认为 golang 因为没有继承无法实现 factory 模式，只能停留在 simple factory</p><p>但是品一品 “ 继承只是一种复用代码的方式 ” 这句话，我觉得 golang 应该是能实现的</p><p>之后有空了把代码贴出来</p></blockquote><h4 class="anchor anchorWithStickyNavbar_LWe7" id="builder">Builder<a href="#builder" class="hash-link" aria-label="Direct link to Builder" title="Direct link to Builder">​</a></h4><p>Builder 模式用于优化创建实例的复杂逻辑。</p><p>这种模式其实很常见：</p><div class="language-C# codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C# codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var car = CarBuilder.setWheels(4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .setSeats(1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .setEngine(new engine)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .build()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上图这种链式调用是 builder 模式的一种常见形式。</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDI4MTQ5NTE4MDNjZDMwNTMxODlhMjZkY2JjMjhiYzlfRWs0ZTN1UlhyWlBVeW5hZmRsNVFnakdaUDkwU0g2bFNfVG9rZW46Ym94Y25LcmZxTGxJaHlzWUtBMmV2cnp4dnZhXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p>Builder 模式将创建过程分步进行，相比一次性接收所有初始化参数后返回对象的 constructor，这种形式显然更清晰易懂，便于维护。对于有多种 “可选创建模式” 的类，使用 builder 构建可以避免出现大量的 constructor。而对于创建逻辑比较复杂的类，譬如链状或者树状组合的类，builder 能将复杂的创建流程简化成人能看的地步。</p><p>Builder 模式的一个缺点是其没法从语法上确保创建流程的完整，需要调用者自己记住 build 的流程。一般来说，我们会在最后的 build 步骤加上一些完整性检验作为最后保险。</p><div class="language-C# codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C# codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class Builder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public IProduct build()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(checkIntegrity(this))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw Exception(&quot;Incomplete product&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Product(this);        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Builder 模式不止能用来创建新实例，还可以应用在很多创建场合增加易读性。使用过 gorm 的人应该不陌生，gorm 的链式调用其实就是一个 builder. 其中，<code>where</code> 等方法相当于在设置最终的 sql 语句，而执行性的 <code>find</code> 等方法调用时，gorm 才会生成一个 sql 语句交给数据库执行。</p><div class="language-Go codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Go codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">db.Table(&quot;tableName&quot;).Where(&quot;id = ?&quot;,id).Limit(10).Find(&amp;result)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="prototype">Prototype<a href="#prototype" class="hash-link" aria-label="Direct link to Prototype" title="Direct link to Prototype">​</a></h4><p>在实际应用中，经常出现对象的复制行为。</p><p>我们知道，由于可能出现大量的引用类型和 private 成员，直接复制对象是不太可能的。重新创建一个对象也可能是一件非常复杂的事情，在对对象内部不知情的情况下，可能需要用反射遍历所有字段进行复制。</p><p>但是，对象本身拥有其所有成员的访问权限，可以直接遍历字段进行复制。所以，不如把复制工作交给对象本身。</p><div class="language-Python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Python codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Prototype:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def __init__(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.int_member = 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.list_member = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def clone(self):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newObj = self.__class__()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newObj.int_member = self.int_member</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        newObj.list_member = copy.deepcopy(self.list_member)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # iterate all members</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return newObj</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="更多设计模式">更多设计模式<a href="#更多设计模式" class="hash-link" aria-label="Direct link to 更多设计模式" title="Direct link to 更多设计模式">​</a></h3><p>这些设计模式更偏向一个 “有趣的点子”</p><p><strong>可能需要更多的实际例子来介绍应用场景。</strong></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="wrapper">Wrapper<a href="#wrapper" class="hash-link" aria-label="Direct link to Wrapper" title="Direct link to Wrapper">​</a></h4><p>对于面向接口的编程来说，经常有实际组件对不上设计好的接口的情况。</p><p>如果不想修改接口和接入的代码，一般会选择对接口进行一个 “包装”。使用一个 <code>Wrapper</code> 类来实现所需要的接口，然后将实际功能 delegate 给原来的组件。</p><p>暂时无法在飞书文档外展示此内容</p><p>有很多设计模式本质都是一个 wrapper。</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=N2NjNWI1NzdjN2E5OGUxOWJmN2UyNjA3MjVjNGM0OGFfZWVsamNaaFJHeFdVVDc5Y3FSZDdMNjRQYk5uME1vT2ZfVG9rZW46Ym94Y25lS0hXcVQ5WnJNbVNDMGd6Y2ZJU1FmXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=OWU5ZGRmYjZmODM1ZjU2M2M4MzI5OWJiOWRiYzVhOWZfZVdCM0FGRFNVWlVRQnVZSEpOSVk2NHVDM3hoTGw5dkdfVG9rZW46Ym94Y25YaUM5dnUyYklrdEdXbEw2U0QybHBnXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p><strong>Adapter</strong> 通过一个 wrapper 类来对接两个接口之间的功能。<strong>Facade</strong> 类似于用一个较简单的接口调用一个复杂组件的功能。<strong>Proxy</strong> 模式则是利用 wrapper 进行一些统一管理，比如进行 log 或者控制缓存。</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=N2I1MGYzNTQwMzJkNWVkMTViNzFlZWVjMzFlYTBjYmNfUlI0aTJmclN5a1REY1dVV09DY005VFQ3T3ZjT29ubkdfVG9rZW46Ym94Y256NVkwUFRXZVdaV2tLSmpGYTJJMkZjXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=M2YwZjgxYWI3Y2VlM2JhZDNlMjBhZGUyYTk4OTE4YThfdFhhVWxZZVEwU1c3OGpROGdYOHhLeUt5alNNeGM5MXJfVG9rZW46Ym94Y25uUUZ4REtzbHFGcEZVNnA0ZUdTS25lXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p>有时候，包装前后的接口其实是一样的，我们只是想在原来接口执行的前后增加功能，这种模式被称为 <strong>Decorator.</strong></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="chain-of-responsibility">Chain of Responsibility<a href="#chain-of-responsibility" class="hash-link" aria-label="Direct link to Chain of Responsibility" title="Direct link to Chain of Responsibility">​</a></h4><p>责任链模式是一种分离职责的做法。</p><p>这种模式将一个需要处理的事件抽象成一个 <code>event</code> 接口，然后再将处理事件的函数通进行链状储存。每当有一个新的事件需要处理时，一个 <code>event</code> 实例会被从链头的方法开始被处理，然后逐个交给之后的处理方法处理。</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=YWU2Mzk2M2Q2OWYzNzc5MWJlMmI1YWU5NDUyM2U4YTBfT3lEMjJNVm9WeVVZUEE1TGpVVktCYTJxTERwMkdhT0VfVG9rZW46Ym94Y25QNURiUkpnOUk4N1p3MWJVTHNtMUZoXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p><p>上图的处理方法之间是单向关系，我们也可以使用类似 <strong>decorator</strong>的形式，让整个处理链变成包含关系。</p><p>责任链也可以不必是链状的，只需要实现一个 <strong>Iterator ，</strong>处理函数可以被连接成树状或者其他数据结构。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="composite">Composite<a href="#composite" class="hash-link" aria-label="Direct link to Composite" title="Direct link to Composite">​</a></h4><p>Composite 是一种树状结构。</p><p>这种结构类似于一个军队的管理体系，整个军队的士兵和编制都实现同一个 “行动” 接口，对于士兵来说，这个接口就是执行进攻命令，对于军官来说，这个接口需要先将命令传达给下级士兵，然后再执行命令。而指挥官进行指挥时，只需要对比较顶层的编制进行下令，就能命令整个军队。</p><p><img loading="lazy" src="https://xn4zlkzg4p.feishu.cn/space/api/box/stream/download/asynccode/?code=ODc4OTgyM2ZhNWQ2NGQ3NTlhNDNiM2U0M2E1NTY0OThfVFRCSWxVelNocVRTYkpDeGdWMkVDMnh5czRIOHRrMXhfVG9rZW46Ym94Y25uanFZbTA5WDdIblRaTlJvdU54bDBZXzE2OTY3NzQ5MDA6MTY5Njc3ODUwMF9WNA" alt="img" class="img_ev3q"></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/basics/design/design-intro.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/cs-engineering/docs/category/设计模式"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">设计模式</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/cs-engineering/docs/category/linux"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Linux</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#clean-code" class="table-of-contents__link toc-highlight">Clean Code</a></li><li><a href="#refactoring" class="table-of-contents__link toc-highlight">Refactoring</a><ul><li><a href="#简单直观的重构" class="table-of-contents__link toc-highlight">简单直观的重构</a></li><li><a href="#考虑-代码结构" class="table-of-contents__link toc-highlight">考虑 “代码结构”</a></li><li><a href="#something-deeper" class="table-of-contents__link toc-highlight">Something Deeper</a></li></ul></li><li><a href="#ood-principle" class="table-of-contents__link toc-highlight">OOD Principle</a><ul><li><a href="#dependency-inversion" class="table-of-contents__link toc-highlight">Dependency Inversion</a></li><li><a href="#open-close" class="table-of-contents__link toc-highlight">Open Close</a></li><li><a href="#liskov-substitution" class="table-of-contents__link toc-highlight">Liskov Substitution</a></li><li><a href="#single-responsibility" class="table-of-contents__link toc-highlight">Single Responsibility</a></li></ul></li><li><a href="#interface-segregation" class="table-of-contents__link toc-highlight">Interface Segregation</a><ul><li><a href="#least-know" class="table-of-contents__link toc-highlight">Least Know</a></li></ul></li><li><a href="#design-pattern" class="table-of-contents__link toc-highlight">Design Pattern</a><ul><li><a href="#structure" class="table-of-contents__link toc-highlight">Structure</a></li><li><a href="#creation" class="table-of-contents__link toc-highlight"><strong>Creation</strong></a></li><li><a href="#更多设计模式" class="table-of-contents__link toc-highlight">更多设计模式</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cs-engineering/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cs-engineering/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/cs-engineering/assets/js/runtime~main.363a3de4.js"></script>
<script src="/cs-engineering/assets/js/main.8268da69.js"></script>
</body>
</html>