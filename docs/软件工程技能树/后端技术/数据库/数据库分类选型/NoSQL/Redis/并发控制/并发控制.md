---
title: 并发控制
slug: 并发控制
sidebar_position: 3
---


# 并发控制

Redis的请求是单线程工作的，即每一条指令是满足原子性的，根据请求顺序先后执行

# 使用单条指令代替

redis提供了繁多的多操作指令；可以使用这些指令代替多次执行指令带来的数据写入冲突

例如，用incr来代替get x then set x+1

# 使用事务的watch

通过事务的watch，当多个请求并发写入同一个key时，只有最先写入的返回成功，其余事务全部被watch的变量监控所终止

# 使用Lua脚本作为原子指令

据说lua脚本会作为一条指令来对待，保证修改的原子性

# 原子性带来的问题

当然，Redis作为单线程模型，如果一条原子操作占用了大量时间，则会阻塞后续请求，导致效率问题

（虽然纯内存操作一般不会占用大量时间）

