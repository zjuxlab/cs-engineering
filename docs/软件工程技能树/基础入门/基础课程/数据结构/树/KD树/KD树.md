---
title: K-D树
slug: K-D树
sidebar_position: 3
---


# K-D树

K-D Tree （K-Dimension Tree）。用于处理$k$维空间的信息。

$k=2$在实际应用中比较常见，（在牺牲一些时间复杂度的情况下大幅度降低编程复杂度），代替一些比较复杂的二维数据结构。

这种数据结构通常用来解决平面最近点对的问题（基于距离的问题），也可以用作搜索问题中的剪枝优化。

<b>那么K-D Tree到底是什么呢？</b>

它代表着多维空间的一种划分，同时描述着点之间的位置关系。

> <b>k-d树的本质是一棵二叉搜索树</b>：对于每个子树，它都象征着一个$k$维的超长方体，它的根节点存储着一个$k$维空间内的点（这个点通常位于这个$k$维超长方体的边界），同时，定义了一个经过该点的$k-1$维度方程，将该子树象征的空间再次划分为两个次级的$k$维空间，作为它左右子树，并按此递归定义。

K-D Tree 可以将 $k$ 维空间上的 $n$ 个点分成 $\log n$ 层，每个节点的左子树上所有节点的某一维坐标都比自己小，右子树上所有节点的某一维坐标都比自己大。进而可以做到 $O(\log n)$ 的修改和 $O(n^{1-\frac 1k})$ 的高维长方体查询。

例如当 $k=2$ 时，查询复杂度即为 $O(\sqrt n)$，实际应用时效率远低于同样可以做矩形查询的带修主席树和分块。不过因为 K-D Tree 有非常大的空间优势，所以它还是有一定的用武之地的。

$k=3$ 时，查询复杂度为 $O(n^{\frac 23})$。在 $n\leq 10^5$ 时，四维偏序问题使用 K-D 树的效果是略高于 $O(\log^3 n)$ 的各种算法的。

k 更高时，在现有条件下（即不超过 $10^{10}$ 次运算）K-D Tree 的实际效率已经低于 $O(n^2)$ 的常数比较优秀的暴力。因此我们一般仅在二维和三维空间中应用 K-D Tree。

<b>二维情况：</b>

我们以一个2维平面为例：考虑平面内分布着一些无序的点：$(x_i,y_i),i=1,\ldots,N$。

每一个点象征着一个长方形区域，根结点象征的区域为$\{(x,y)|x,y\in(-\infty, \infty)\}$。

对于每个节点，经过它做一条平行于x轴或者y轴的直线，将当前区域分割为两个长方形，所有位于其中一个区域的点进入它的左子树，位于另一个区域的点进入右子树。

如下图所示：

![](/assets/JJTbbH3dmoj5mBx9GMec7pHZnNh.png)

则建出来的K-D Tree形如：

![](/assets/POK9bBxJhoPvmqx2y3fctYmMnab.png)

三维的 K-D Tree：

![](/assets/RCNpbxXi8oCWsXxiTTFcAtKDned.png)

# 如何建树

在了解了K-D Tree的形成机制后，便可以按照朴素的方法进行建树了。

在建树的过程中，我们主要需要考虑如下问题：

- 如何保证 K-D Tree 的形状较为优雅（防止退化的情况）：可以发现，如果尽可能的控制左右子树的大小相当，则可以使得整个树的高度为 $O(\log n)$，以此可以保证后续执行搜索算法的时候复杂度可以保证。——若当前子树依照第$i$维来分割空间，则选择当前空间内点中第$i$维坐标恰好为中位数的那个点。
- 如何使得 K-D Tree 在拥有更加强大的信息处理能力：考虑到K-D Tree主要的功能是依照空间内点的距离来访问一些较为靠近的点的信息，而较为靠近的点通常位于几个子树内部，在搜索的过程中会根据当前子树象征空间的与带查询点（或者空间）的距离来决定是否递归进入该子树，而如果需要搜索到的子树较多的话，则剪枝力度就不够优秀。为此，我们希望尽可能地不要出现划分的区间内的点的距离仍然十分相近的情况。——选择的维度要满足其内部点点分布差异度最大，即每次选择点切割维度是方差最大的维度。

例如下图：沿$x=5$切割平面要优于沿$y=3$切割平面，因为后者可以让点<b>更加分散。</b>

![](/assets/Qp56bDuyJoLY6hxdDl3c07xoneb.png)

> 在实际建立K-D树的过程中，有的时候为了方便省事，往往直接按照第$1,2,\ldots,k$维交替作为划分空间的维度，（比如二维空间，先纵向划分，再横向划分，交替进行），因为这样往往也能达到比较好的划分效果，并且可以简化代码。

## 建树过程

接下来考虑 K-D Tree 的建树过程。

假设我们已经知道了$k$维空间内的$n$个不同的点的坐标，要将其构建成一棵 K-D Tree，步骤如下：

1. 若当前超长方体中只有一个点，返回这个点。
2. 选择一个最佳的维度，选取该维度位于中位数的点，并以这个点的坐标为分割凭据，这个维度上的值小于这个点的点归入左子树，反之，归于右子树。
3. 将所选择的点作为这棵子树的根节点，递归对分出对两个超长方体构建左右子树，维护子树信息。

<b>如何寻找一个维度上位于中位数的点？</b>

如果直接排序，则总的建树复杂度为$O(n\log^2 n)$。然而我们每一次要执行的操作其实只有找到中位数，将大于中位数的一半点放到点列左边，大于的一半放在右边。考虑快速排序的过程，选择一个key值，扫描序列，然后将小于 key 值的一半放到左边，大于 key 值的一半放到右边。由于不需要将序列完整排序，此时只需要计算一下中位数是大于key值还是小于key值，然后进入中位数所在的那边区间即可。可以证明，对于长度为$n$的序列执行单次该操作的均摊时间复杂度是$O(n)$。因此k-d树的建树过程可以优化到$O(n\log n)$。

> C++的`algorithm`库中的`nth_element()`函数可以以期望复杂度$O(n)$来寻找一个序列里按照一个规则排序后第$k$位的值，并将其放于第$k$位置上。
> 具体写法为：
> ```cpp
// 找到区间s[l:r+1]中排序后位于s[mid]的数。
// 比较函数为cmp,默认为从小到大排序。
nth_element(s+l, s+mid, s+r+1, cmp);
```

参考代码如下：

```cpp
// 2-d Tree
const int N = 2e5+5;
int n, m, D, rt, cnt = 0;
struct point{ // 表示二维平面上的一个点
    int x[2], id;
    point(){}
    point(int a, int b, int c=0) { 
        x[0] = a;
        x[1] = b;
        id = c;
    }
    bool operator < (const point& p) const{
        return x[D] < p.x[D];
    }
}a[N];
struct node{ // 表示 2-d Tree 上的一个节点
    int mx[2], mn[2], lc, rc;
    // mx[], mn[]，记录矩形的边界
    // lc， rc，记录左右节点的标号
    point pos;
}tr[N];
#define ls tr[x].lc
#define rs tr[x].rc
//更新当前节点的信息
inline void upd(int x){
    for(int i=0;i<2;++i){
        tr[x].mn[i] = tr[x].mx[i] = tr[x].pos.x[i];
        if(ls) {
            tr[x].mx[i] = max(tr[x].mx[i], tr[ls].mx[i]);
            tr[x].mn[i] = min(tr[x].mn[i], tr[ls].mn[i]);
        }
        if(rs) {
            tr[x].mx[i] = max(tr[x].mx[i], tr[rs].mx[i]);
            tr[x].mn[i] = min(tr[x].mn[i], tr[rs].mn[i]);
        }
    }
}
// 建树
void build(int& x, int l, int r, int d) {
    if(l>r) {
        x=0;
        return;
    }
    x = ++cnt;
    D = d;
    int mid=(l+r)/2;
    nth_element(a+l, a+mid, a+r+1);
    tr[x].pos = a[mid];
    build(ls, l, mid-1, d^1);
    build(rs, mid+1, r, d^1);
    upd(x);
}
```

# 删除/增加 点

对 K-D Tree 插入点的过程类似于无旋的二叉搜索树，从根节点开始根据当前节点的分割方式决定进入左子树或是右子树，直到遇到空节点，插入该点之后回溯。

对 K-D Tree 删除节点会破坏原先树的结构，因此，只能采用打懒标记的方式来表示当前点已经被删除了，但是仍然保留它在 K-D Tree 上的位置。

在插入或删除点的过程中有可能会破坏树的平衡性。我们引入平衡因子$\alpha$，它是一个常数，若有一个子树的结点数在以$x$为根的子树中占比大于平衡因子，则认为以$x$为根的子树是不平衡的，此时需要重构这个子树，代替原来的树。同样，如果有删除操作，则需要知道当前未删除的结点数为多少，同样，如果如果一个子树内未删除的点不平衡，则重构这个子树。显然，$0.5<\alpha<1$。但 $\alpha$ 过小或过大显然都不合适。我们一般将 $\alpha$ 设为 0.75 左右。

该重构方法类似替罪羊树，套用势能分析可以发现，单次插入/删除的复杂度均摊为$O(\log^2 n)$，常数一般，实现比较麻烦。

带重构的 K-D Tree 的树高仍然是$O(\log n)$的。

> 除了上面讲到的重构方式，还有一个比较常用的重构规则：每操作$limit$次就强制重新构造一次整棵树。这样可以保证复杂度在$O(\frac{n}{limit} n \log n)$，并且写起来比较简单，但是常数很大，在复杂度允许的时候，可以替代上面的重构方法。

K-D Tree 的插入：

```cpp
const double alpha=0.75;
int cnt;
void flat(int x){ // 重构函数
    flat(tr[x].lc);
    a[++cnt]=tr[x].pos;
    flat(tr[x].rc);
}
void check(int& x,int d){
    int tmp=tr[x].sz*alpha;
    if(tr[lc].sz>tmp||tr[rc].sz>tmp)
        cnt=0,flat(x),build(x,1,cnt,d);
}
void insert(int& x,int d,point p){
        if(!x){
                x=++cnt;
                tr[x].pos=p,tr[x].lc=tr[x].rc=0;
                upd(x);return;
        }
        if(tr[x].pos.x[d]<p.x[d])insert(rs,!d,p);
        else insert(ls,!d,p);
        upd(x);
    check(x,d);
}
```

# 最邻近查询

> 说是最邻近查询，其实也类似的方法查询最远点。

K-D Tree 最常见的应用就是寻找最近点对。该类题型可以使用分治来求解，也可以使用 K-D Tree 来求解，它们的本质都是搜索剪枝。

<div class="callout callout-bg-14">
<div class='callout-emoji'>❔</div>
<p>给定平面上$n$个点$(x_i, y_i)$，找出平面上最近两个点对之间的欧几里得距离/曼哈顿距离/切比雪夫距离。</p>
<p>$$2\le n\le 200000, 0\le x_i,y_i \le 10^9$$</p>
</div>

做法：建立$n$个点 K-D Tree。我们可以对每个结点分别寻找离它最近点，同时维护当前最优的答案。K-D Tree 对于空间的划分可以使得在搜索最近的点的时候可以进行显著的剪枝，具体的做法为：记录下当前子树的边界值（每个维度的坐标范围），可以根据这些边界值计算出当前点到这个超长方体的最近距离（最为当前节点的估价函数），如果这个距离已经大于当前的答案，则不需要搜索这个子树内的点。

> 其他优化：如果一个结点两个子树都可能包含答案，则先搜索距离当前点更近的超长方体对应的子树。

<b>时间复杂度</b>：最邻近查询对于随机数据的复杂度为$O(\log{n})$。但是对于构造性的数据无法保证稳定性。

## K邻近查询

对于一个点查询距离其距离第$K$近的点，做法类似于最邻近查询，只需要在搜索的时候维护一个大小不超过$K$的小根堆就可以了，做法类似于$K$短路。

# 矩形查询

<div class="callout callout-bg-14">
<div class='callout-emoji'>❔</div>
<p>平面上有$n$个点，支持矩形内点权修改，矩形点权和查询，矩形点权最值查询，强制在线。</p>
<p>$$2\le n\le 50000, 0\le x_i,y_i \le 10^9$$</p>
</div>

> 该题如果支持离线处理，则只需要对所有操作增加一个时间戳，转化为三维数点问题，然后就可以使用 <b>CDQ分治 </b>解决。

使用二维数据结构（线段树套线段树）可以解决这个问题，但是较为复杂，并且需要$O(n\log^2 n)$的时间复杂度和$O(n\log n)$的空间复杂度。

使用 2-D Tree 可以在$O(n)$的空间和$O(n\sqrt{n})$的时间内解决该问题，同时复杂度很小。

建出2-D Tree之后，维护每个节点的信息（矩形内权值和+最值）。在搜索的过程中，如果当前矩形和给定的矩形没有交，则不需要进入该层搜索，如果完全包含于给定的矩形，则可以$O(1)$更新答案，如果不是上述两种情况，则需要进一步递归进入该层子树。

```cpp
//矩形和查询
int query(int x,int lx,int ly,int rx,int ry){
    if(!x)return 0;
    if(tr[x].mn[0]>=lx&&tr[x].mn[1]>=ly&&tr[x].mx[0]<=rx&&tr[x].mx[1]<=ry)
        return tr[x].sum;
    if(tr[x].mn[0]>rx||tr[x].mn[1]>ry||tr[x].mx[0]<lx||tr[x].mx[1]<ly)
        return 0;
    return (tr[x].pos.x[0]>=lx&&tr[x].pos.x[0]<=rx&&
    tr[x].pos.x[1]>=ly&&tr[x].pos.x[1]<=ry?tr[x].pos.val:0)
        +query(ls,lx,ly,rx,ry)+query(rs,lx,ly,rx,ry);
}
```

该剪枝的最劣单次操作复杂度为$O(\sqrt{n})$，并且是稳定的。

> 我们知道线段树和平衡树的查询可以将原区间分解为不多于 $2\log n$ 个区间。
> K-D Tree 的查询呢？以 2-D Tree 为例，考虑每两层。
> 首先<b>至多只有一次查询会同时进入四棵子树</b>，后面待查区域必然在子树区域的一个角落。
> 此时，一定有至少一个区域完全包含在待查区域，或与待查区域交集为空。
> 在最坏情况下，另外三个区域均需要继续递归。但其中两个区域的一个维度完全包含待查区域中，另一个区域在最坏情况下递归了原问题。即：
> $$
T(n)=T(\dfrac n4)+2T'(\dfrac n4)$$
> 而 $T'(n)=2T'(\dfrac n4)$，因此 $T'(n)=O(\sqrt n)$。
> 故 $T(n)=T(\dfrac n4)+2O(\sqrt {\dfrac n4})=T(\dfrac n4)+O(\sqrt n)$。
> 即 $T(n)=O(\sqrt n)$。单次查询的复杂度为 $O(\sqrt n)$。
> 同理我们可以分析出 K-D Tree 单次查询的复杂度为 $O(2^kn^{1-\frac 1k})$。

# 其他修改操作

## 单点修改

类似平衡树，$O(\log n)$知道修改节点直接修改即可。

## 矩形修改

用和矩形查询一样的思想剪枝，找到所有包含于修改矩形的节点，用打标记的思想修改即可，每次访问到一个节点都需要下传标记，单次操作的复杂度显然也是$O(\sqrt{n})$的。

# 应用

<div class="callout callout-bg-14">
<div class='callout-emoji'>❔</div>
<p>询问区间只出现了一次的最大的数。强制在线。</p>
<p>$$n\le 10^5,m\le 2\times 10^5,a_i\le n$$</p>
</div>

对于 $1\le i \le n$，定义$pre_i$，为$a_i$上次出现的位置，$nex_i$为下次出现的位置。

这样一个数可以被看成$(i,pre_i,nxt_i)$这样一个点，点权为$a_i$。

对于查询区间$[l,r]$，相当于查询$l\le i\le r, pre_i < l, nxt_i > r$的点权最值。

可以使用 3-d Tree 实现，时间复杂度为$O(n^{\frac{5}{3}})$，空间复杂度为$O(n)$。

<div class="callout callout-bg-14">
<div class='callout-emoji'>❔</div>
<p>给定一棵以 1 为根的有根树，初始所有节点颜色为 1，每次将距离节点$x$不超过$l$的$x$的子节点染成$c$ ，或询问点$x$的颜色。<br/>$n\le 10^5$</p>
</div>

每个点子树对应 dfs 序的一个区间，距离不超过$l$对应深度的一段连续区间，每个树上节点可以转化为$(dfn_i,deep_i)$一个二维平面上的点。套用 2-D Tree 的做法。

时间复杂度$O(n\sqrt{n})$，空间复杂度$O(n)$。（比写得丑的二维线段树块）。

<div class="callout callout-bg-14">
<div class='callout-emoji'>❔</div>
<p>有$𝑛$个圆，每次找到这些圆中半径最大中的编号最小的圆，删除它及与其有交集的所有圆。对于每个圆，求出它是被哪一个圆删除的。</p>
</div>

K-D Tree，每个点表示这个圆的外接矩形，排序后直接暴力搜索，相当于在搜索过程中进行了剪枝，复杂度玄学，但是好写。

