---
title: è´Ÿè½½å‡è¡¡å™¨
slug: è´Ÿè½½å‡è¡¡å™¨
sidebar_position: 1
---


# è´Ÿè½½å‡è¡¡å™¨

Authorï¼šNA

å› ä¸ºæ½®ä¸šåŠ¡æ‰‹æ“çš„ä¸€ä¸ªè´Ÿè½½å‡è¡¡å™¨ï¼Œä¸»è¦åŒ…æ‹¬äº†nginxæ—¥å¿—ç›‘æ§ã€perfç›‘æ§ã€è´Ÿè½½å‡è¡¡ç­‰åŠŸèƒ½ã€‚

è¿›è¡Œäº†ä¸€äº›ç®€å•çš„å‹æµ‹ï¼Œå·¥å…·å’Œè¿‡ç¨‹ä¹Ÿæ”¾åœ¨é‡Œé¢ã€‚

repoï¼š

follow me fromï¼š

https://t.me/+5IH64rSM3AVmN2M1

# Developing in `golang`

Some tricky topics involved:

- Multithread and stubborn queue control.
- Build a stubborn performance test and `goroutine` leak test.
- Why you should close file description in each channel.

## Building a go program with RESTful template

Reusable code:

- RESTful router.
- Definition and Handler of object.

more.

You may want to define and expose RESTful apis along with the definition of objects. And build the template of project.

## The main part of a proxy

Code.

Tricky:

- Be sure to Close each side when the other side sends EOF.
    - Achieve with defer.
    - Never Close unopened connection.

- &lt;aside&gt; ğŸ‘‰ Set defer to close right after establishing. Be careful with â€œClosing not opened.â€
- &lt;/aside&gt;
- Recycle resources.
    - No forever hang connection and `goroutine` leak: Closing each side and timeout.
    - No global variable creation. All local variables are released to ensure no memory leak.

- Display readable error message when fault occurs.

# Random and Hash

Topic about load balancing? Which is better?

Random

`Intn()` and `rand()` % ? Why â€œNot equal possibilityâ€?

## Hash

Rand and Hash.

- Rand mechanism. Possibility distribution.
- Easy hash is `mod`. Length may affect performance. Sparse would cause waste.
    - Sparse cost for hash?

- Weighted distribution.

# Prometheus Metrics

To enable monitoring, I need to expose this as prometheus metrics.

# Automatic basic test

How do you compose a automatic tester? Not just inside golang itself. You may want to build a integrated test and run by itself.

# Promotion to be a c10k

# Build test

- Memory use. Channel use.
- Response time.
- Overloading performance.

# Perfing Golang

[[golang]7ç§ Go ç¨‹åºæ€§èƒ½åˆ†ææ–¹æ³•](https://www.cnblogs.com/landv/p/11274877.html)

Go Executable runs in many layers of environments:

- Operating system: OS.
- go runtime.

With these, you can glean some useful statistics:

- Time: /usr/bin/time
- fd: File descriptor
- IO and net work.
- GC behavior.
- Memory.
- CPU time hotspot.

How do you gather these statistics?

â‡’ Build a generic perf render.

## Naive performance test

To avoid networking bottleneck, test local io loopback bandwidth with `iperf`

```go
iperf3 -s 15999
iperf3 -c 127.0.0.1 15999
```

Watch the traffic on network interface with `iftop`

```go
sudo iftop -i lo -nN
```

Get performance.

Easily get:

- `iftop` has shown exact band rate with `iperf3`.
- With huge `io` , CPU cores are busy with sending packages. The bottleneck for `lo` is cpu now. ğŸ˜… â€¦ok.

æƒ³æƒ³åœ¨ä¸€å°è™šæ‹Ÿæœºä¸Šè‡ªå·±å¯¹è‡ªå·±å‹æµ‹æœ‰ç‚¹è ¢ï¼Œæ›´æ¢ä¸¤å°ç‰©ç†æœºæµ‹è¯•ğŸ˜¦

## Perfing

é¢„æµ‹è¯•ï¼š

- ä¸ç»è¿‡ä»£ç†æœåŠ¡å™¨ã€‚
- å·¦ä¾§ä¸ºsrv2ï¼ŒåŒ…å«å¾…æµ‹æœåŠ¡ï¼›
- å³ä¾§ä¸ºsrv1ï¼Œä¸ºå‹æµ‹æœºï¼Œå«æœ‰æµ‹è¯•ç¨‹åºabã€å—æµ‹ä»£ç†çš„è®¿é—®ç›®æ ‡nginxã€‚

ç¬¦åˆé¢„æœŸï¼Œæœºå™¨æ˜¯ç”±ç™¾å…†äº¤æ¢æœºè¿æ¥çš„ã€‚

To take a glimpse at the performance, `ab` from apache-utils comes in handy.

```go
sudo apt-get install apache2-utils
```

[ab - Apache HTTP server benchmarking tool](https://httpd.apache.org/docs/2.4/programs/ab.html)

For io pressure is considered dangerous for linux, some mechanism would limit the rate. Some options to be tuned:

- ulimit 20000
- net.ipv4.tcp_syncookies = 0

å—¯ï¼Œæœ€ååƒæ¨¡åƒæ ·åœ°è·‘äº†ä¸ªæµ‹è¯•ï¼Œå‘ç°è´Ÿè½½å®Œå…¨ä¸åœ¨ioä¸Šï¼Œåœ¨cpuä¸Šï¼ˆ

### æµ‹è¯•:

- ç¯å¢ƒåŒä¸Šã€‚ä»ç•¥

```bash
sudo ab -c 1000 -n 10000 -H "ip.zjuqsc.com" -H "X-Egress-Scheme: http" \\
        -H "X-Egress-Host: 172.20.216.100:80" -r <http://10.76.8.19:18999/>
```

é™ç½®æœºå™¨ï¼š

è¿è¡Œåˆ°ä¸­æ®µç¨³å®šçŠ¶æ€ï¼š

æµ‹è¯•ç»“æŸï¼š

- è´Ÿè½½æƒ…å†µï¼š
    - ä¸šåŠ¡æœºcpuè·‘æ»¡ã€‚æš‚æ—¶æœªçŸ¥ä¸ºå•¥è¿™ä¹ˆåƒUï¼›
    - æµ‹è¯•æœºå’Œä¸šåŠ¡æœºä¹‹é—´çš„ioæ²¡æœ‰æ»¡ï¼Œä¸æ˜¯ç“¶é¢ˆï¼›
    - æµ‹è¯•æœºæœ¬èº«çš„coreæ²¡æœ‰è·‘æ»¡ï¼Œç“¶é¢ˆä¸åœ¨nginxç»ˆç«¯æœåŠ¡ä¸Šã€‚

- èµ„æºæ¶ˆè€—ï¼š
    - çœ‹äº†ä¸€ä¸‹ä¸šåŠ¡çš„memoryæ¶ˆè€—ï¼Œä¸€å¼€å§‹æ˜¯450Må·¦å³ï¼Œè·‘åˆ°ä¸­æ®µæ˜¯685Mï¼Œæœ€åæ˜¯772Mã€‚å…¶ä¸­ç»å†äº†15ä¸‡æ¬¡è¯·æ±‚ã€‚ä¹‹åè®¡ç®—å¹³å‡æ¯è¯·æ±‚å’Œåº”æœ‰çš„å·®å¼‚ï¼Œä»¥ç¡®è¯memoryleakï¼›è¿‡äº†åå‡ åˆ†é’Ÿåˆä¸‹æ¥äº†ä¸€äº›ï¼Œçœ‹ä¸Šå»æ˜¯å› ä¸ºgcæ…¢æ…¢ä¸‹æ¥äº†â€¦
    - è‡³å°‘å­˜æ´»äº†â€¦

- Dump æ—¥å¿—è¿›è¡Œåˆ†æï¼š
    - json å…¨åºåˆ—åŒ–çš„å¤§å°åªæœ‰16MBï¼Œè¿™ä¹ˆçœ‹æ¥æ˜¾ç„¶memoryleakäº†ï¼ˆ

# Monitor and Debug

Use golang `runtime` to inspect usage and goroutine leak for golang.

- Memory allocation and GC.
- Goroutine statistics.
- File descriptor.

## System side

```bash
# system
sudo systemctl status ipmanager.service
```

æš‚æ—¶åœ°è§‚å¯Ÿfdï¼Œå¯ä»¥ç”¨ï¼š

```bash
sudo lsof -a -p <PID>
```

å¯ç”¨äºæ£€æŸ¥è¿æ¥æ˜¯å¦è¢«æ­£å¸¸å…³é—­ã€‚

## Runtime perf

runtime provides:

To Enable

```bash
# pprof 
(go tool )pprof -http=:9099 <http://10.76.8.19:9091/debug/pprof>
```

## CoreDump

To enable core dump, set limit:

```bash
ulimit -a # system limitation of system resources.
ulimit -S -c unlimited #
ulimit -S -c 1073741824 # 1G (by default in B)
```

To trigger coredump manually:

```bash
kill -s SIGSEGV <PID>
```

&lt;aside&gt; ğŸ‘‰ Note: `Systemctl` service produced no coredump by default. Rather than `ulimit`, `LimitCORE` needs to be set. Refer to:

&lt;/aside&gt;

[systemd.exec](https://www.freedesktop.org/software/systemd/man/systemd.exec.html#Process%20Properties)

Or, you can produce coredump with gdb:

```bash
sudo gdb -p <pid>
gcore
```

Download from origin: (1G).

- Including different `.so` filesâ€¦

# Debug

&lt;aside&gt; ğŸ‘‰ You canâ€™t use a blocking function in goroutine if you canâ€™t guarantee itâ€™s safeâ€¦ You canâ€™t break goroutine from outside, and you canâ€™t use signal to stop the blocking function. You can only rewrite them.

&lt;/aside&gt;

The `io` package has provided primitives of `io`, hiding the complexity of tcp protocol. You are actually reading from and writing to a stream.

But from this, you are limited to its implementation without timeout. Custom `CopyWithTimeout` needs to be implemented.

## `io`: Streaming Reader

Golang provides `io` as the primitives managing reading and writing. The object implementing these interfaces may comes from different systems.

There are several featured functions:

### `io.Copy()`

Try to call `ReadFrom` and `WriteTo()`

If none, try to allocate a buffer and use for copying.

Promotion:

- `io.CopyWithBuffer`: Use provided buffer.
- Use `bufio` for buffered `io` reading and writing. More featured methods and much more efficient for small `io`reading.

Drawbacks:

- Blocking. No interrupt allowed. So you canâ€™t use it with clock.

# TCP Proxy: From byte to byte

---

[Goç»å…¸é˜»å¡å¼TCPåè®®æµè§£æçš„å®è·µ](https://mp.weixin.qq.com/s/NG3f-KkjtJBTVdRHQKLXOg)

# AB Test with `nginx`

`nginx` split client.

```go
split_clients "${remote_addr}AAA" $variant {
               0.5%               .one;
               2.0%               .two;
               *                  "";
}
```

Used for A/B Testing. Tracing log to show split? (Add header and Log.)

## TODOS

More flexible IP log fetching.

- Streaming huge json objects. (Over 16M).

Refer to benthos source code for overview of streaming:

[https://github.com/benthosdev/benthos](https://github.com/benthosdev/benthos)

Debug under pressure.

- Analyze core-dump !!!
- Analyze with go perfing !!!

Inspect and track from systemctl.

- More precise usage?

# è¸©å‘è®°å½•

Channel and goroutine

```go
func Proxy(src net.Conn){
        var d string
        if config.C.Debug {
                // TODO: Configurable load balancing: Marking upstream and set upstream by hand.
                d = "127.0.0.1:19106"
        } else {
                d = LoadBalance()
        }

        dst, err := net.DialTimeout("tcp", d, time.Duration(config.C.DialTimeOut)*time.Second)

        if err != nil {
                fmt.Println("dial failure to service detected: " + err.Error())
                // TODO Send back timeout info.
                src.Write([]byte("HTTP/1.1 502 Bad Gateway\\n\\r[PROXY RESENDING ERROR FROM UPSTREAM:]\\n\\r" + err.Error() + "\\n"))
                src.Close()
                return
        }

        if Gate(src) != nil {
                fmt.Println("Gate.")
                return
        }

        done := make(chan struct{})
        // To make a duplex channel, you may need two goroutines.
        // Copy is streaming. It returns when EOF reaches.

        defer func() {
                dst.Close()
                src.Close()
        }()

        go func() {
                io.Copy(dst, src)
                done <- struct{}{}
        }()
        go func() {
                io.Copy(src, dst)
                done <- struct{}{}
        }()

        select {
        case <-done:
                return
        case <-time.After(time.Duration(config.C.MaxConnectionTimeout) * time.Second):
                fmt.Println("Connection timeout.")
                src.Write([]byte(TimeOut))
                dst.Write([]byte(TimeOut))
        }
        // Either side connection close would cause "defer: Send EOF and close connection."
}
```

&lt;aside&gt; ğŸ‘‰ This is problematic code, causing memory leak. Can you see whatâ€™s the problem?

&lt;/aside&gt;

Goroutine probe:

â€¦Oh.. `proxy()` Not releasedâ€¦

These two points where memory leaks:

```bash
go func() {
                io.Copy(*dst, *src)
                done <- struct{}{}
}()
go func() {
                io.Copy(*src, *dst)
                done <- struct{}{}
}()
```

One `goroutine` exited but another didnâ€™t.

I thought:

> When `dst` sends it data and EOF, the last `goroutine` would exit and send through â€œdoneâ€ channel to main thread. But the another side just close the connection but not sending back EOF. Thatâ€™s causing `io.Copy()`blocking.

But file descriptor closed, canâ€™t that cause `io.Copy` returning?

Thatâ€™s not true. For:

- Goroutine canâ€™t be interrupt outside. That means we canâ€™t set a timeout and break the blocked `io.Copy`. If file descriptor closing canâ€™t lead to `io.Copy` to return, thatâ€™s making it a leaked goroutine, just like here. Designer canâ€™t be making things so stupid.
- Besides EOF reaches, errors happening could also cause `io.Copy` to return. As doc mentioned it.

&lt;aside&gt; ğŸ‘‰ Justâ€¦ Read documentation with careâ€¦

&lt;/aside&gt;

So whatâ€™s happening here?

This is a working solution:

```bash
defer func() {
                (*dst).Close()
                (*src).Close()
        }()

        go func() {
                if _, err := io.Copy(*dst, *src); err != nil {
                        return
                }
                done <- struct{}{}
        }()
        go func() {
                if _, err := io.Copy(*src, *dst); err != nil {
                        return
                }
                done <- struct{}{}
        }()

        select {
        case <-done:
                return
        case <-time.After(p.timeOut):
                //fmt.Println("Connection timeout.")
                (*src).Write([]byte(p.timeOutErr.Error()))
                (*dst).Write([]byte(p.timeOutErr.Error()))
                return
        }
```

TODO: Whatâ€™s the precise behavior of channel?

TODO: more about golang GC.

