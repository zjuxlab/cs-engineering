---
title: ELF 与链接
slug: ELF 与链接
sidebar_position: 6
---


# ELF 与链接

Author: 张书怀

大家好，我本次分享的主题为： <b>ELF与链接 </b>

参考书目：《程序员的自我修养——链接，装载与库》

分享原因：无论是在学习计算机系统/操作系统时，都需要对Linker/Loader/Library/ELF等内容有些了解，但往往苦于没有一门专门的课程讲授相关知识。

## 目标文件

现在PC平台流行的可执行文件格式主要是Windows下的PE（Portable Executable）和Linux的ELF（Executable Linkable Fomat），它们都是COFF（Common file format）的变种。<b>目标文件</b>就是源代码经过编译后但未进行链接的中间文件（Windows的.obj和Linux的.o）。

不光是可执行文件（Windows下的.exe和Linux下的ELF可执行文件）按照可执行文件格式存储，动态链接库（DLL，Dynamic Linking Library）（Windows的.dll和Linux的.so）及静态链接库（Static Linking Library）（Windows的.lib和Linux的.a）都按照可执行文件存储。它们在 Windows 下都按照 PE-COFF 格式存储，Linux 下按照 ELF 格式存储。<b>静态链接库</b>稍有不同，它是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，可以简单地把它理解为一个包含有很多目标文件的文件包。ELF文件标准里面把系统中采用ELF 格式的文件归为如表 3-1 所列举的4类。

![](/assets/JUGZbybZrop401xhOLUci9PDncb.png)

### ELF文件结构

在计组/系统相关课程中已经学过了：

![](/assets/EwB6bpSelo8iuyxHaFGc6USJnPb.png)

### 文件头

命令`readelf -h filename.o`可以查看文件头内容。

ELF文件头定义了 <b>ELF魔数，文件机器字节长度，数据存储方式，版本，运行平台，ABI版本，ELF重定位类型，硬件平台，硬件平台版本，入口地址，程序头入口和长度，段表位置和长度及段数量等，</b>其结构为：

```c
typedef structure {
    unsigned char e_ident[16];
    Elf32_Half e_type;
    Elf32_Half e_machine;
    Elf32_Word e_version;
    Elf32_Addr e_entry;
    Elf32_Off e_phoff;
    Elf32_Off e_shoff;
    Elf32_Word e_flags;
    Elf32 Half e_ehsize;
    Elf32 Half e phentsize;
    Elf32 Half e phnum;
    Elf32 Half e shentsize;
    Elf32 Half e_shnum;
    E1f32 Half e_shstrndx;
}Elf32 Ehdr;
```

> 定义在/usr/include/elf.h中，让我们感谢开源

简单来说，各个字段的含义如下：

1. 魔数：标识平台属性，如文件类型，字节序，位数等
2. 文件类型：系统通过这个量判断ELF等真正的文件类型（而不是根据扩展名）
3. 机器类型：如Intel x86

...

### 段表

段表是除文件头外最重要的结构，描述了 <b>段名/长度/偏移/读写权限/其他属性 </b>。可以说，  <b>ELF文件的段结构就是由段表决定的，编译器/链接器/装载器都是依靠段表定位和访问各个段的属性的</b>。段表的位置由文件头中的e_shoff成员决定。

> 以文件头为入口访问段表，再由段表访问段

![](/assets/Ot7Ob6O24owlnkxdsEHcSRJsn3F.png)

### 重定位表

对应段对绝对地址的引用都会记录在对应的重定位表中，如`.rel.text`就是`.text`段段重定位表。

### 字符串表

专门用来放字符串（因为字符串长度未知），别的地方访问字符串只需要访问在表中的偏移即可。ELF文件头中的成员`e_shstrndx`就是段表字符串表的偏移。

<b>只要分析ELF文件头，就可以得到段表和段表字符串表的位置，从而解析整个ELF文件的位置。</b>

## 静态链接

静态链接实际上就是模块间的拼接过程。

一个关键问题是：链接器如何把输出文件中的空间分配给输入文件。即空间与地址分配问题。

最早的方式是 <b>按序叠加：</b>

![](/assets/JPoEbqisFoipiqxvUkncQJ1Ynmg.png)

问题在于输出文件的段过于零散，由于段有对齐要求，即使一个字节的段也要在内存中占用4096字节，会形成大量内部碎片

目前流行的分配方式是 <b>相似段合并：</b>

![](/assets/YnrFb0kpyo7oi3xd8GBcHYZenzg.png)

采用相似段合并的静态链接器一般采用两步链接方法：

- 第一步 空间与地址分配：扫描所有输入，获取各个段长度/属性/位置，收集所有符号定义和引用，放到全局符号表内。链接器能够算出合并后的段的长度和位置，然后建立映射关系。
- 第二步 符号解析与重定位：核心步骤，读取段数据/重定位信息，进行符号解析/重定位/调整代码地址等

> 对于第一步来说，如果用`objdump -h` 查看目标文件的段属性的话，会发现段有两个属性分别为`VMA`/`LMA`，它们分别是虚拟地址和加载地址，正常情况下应该是一样的（但是对于某些嵌入式系统会有一些差别，特别是那些把程序放在ROM的系统，LMA和VMA是必然不同的，这里不展开了，一般只关注VMA）。在链接前，我们可以发现VMA还没有被分配，都是0；链接后，各个段都已经被分配到了对应的虚拟地址。 根据<b>Linux的进程虚拟地址空间分配规则，ELF默认从0x08048000开始分配。</b>对了解过Pwn和逆向或者上过OS课写过Kernel的同学来说应该比较熟悉（

链接过程中的重点其实在于符号的解析和重定位。 <b>“符号”是链接的接口， </b>这一点不难理解，因为访问模块外变量和调用模块外函数本质上都是对变量名/函数名这些符号作解析，解析成它们在内存中的实际地址。

### 符号地址确定

在虚拟地址被计算出来的同时（即链接结束后），各个符号的虚拟地址也就被确定了，因为各个符号在段内的偏移量是固定的。根据段基地址和偏移量就可以确认符号地址。

### 符号解析和重定位

在链接前，文件编译后的变量和函数地址都是0（变量被写为0，函数地址被解析为在原地跳转），也就是说，编译器把符号解析和重定位工作都交给了链接器来做。

#### 重定位表

我们自然要问，链接器是怎么知道要调整哪些指令呢？以及这些指令的哪些部分需要调整，怎样调整？在ELF文件中，存在重定位表的结构专门存储重定位信息。它在ELF中往往是一个或多个段。

一个段往往有一个附属的重定位表，如：`.text`对应的重定位表（重定位段）是`.rel.text`。用objdump的-r参数可以看重定位表：

`$ objdump -r a.o`

每一个要被重定位的地方叫一个<b>重定位入口</b>。重定位入口的偏移用来定位它的位置.

对32位x86机器，重定位表是`Elf32_Rel`结构的数组，每一个元素对应一个入口。

```c
typedef struct {
      Elf32_Addr r_offset
      Elf32_Word r_info
}  Elf32_Rel;
```

  

![](/assets/MAkvbhjrIoMVsjxjQVDcfXLVnPd.png)

#### 符号解析

重定位过程也伴随着符号解析，当链接器要对某个符号的引用做重定位时，就要确定它的地址。方法是找由所有输入目标文件符号表组成的<b>全局符号表</b>。

> 之前已经讲过，在内存分配时 全局符号表已经形成

#### 指令修正方式

如果对汇编语言有所了解，就会知道不同处理器的地址格式不同，不同架构的寻址模式也不同。我们熟知的x86的寻址模式多的令人发指，RISCV的寻址模式只有四种。但是对于32位的x86机器的ELF文件重定位入口所需要修正的寻址方式只有两种：

- 绝对近址32位寻址
- 相对近址32位寻址

对应修正规则如下：

![](/assets/FUKdb8HtLoVA2Cxo15OcecRXnxc.png)

### 静态库链接

下面对静态链接应用的一个重要场景作介绍。

<b>程序如何使用OS提供的API？</b>一种语言的开发环境往往会附有语言对应的库，他们是对API的封装。本节只是简单地介绍静态库的链接过程。

一个静态库可以看成一组目标文件的集合。比如在Linux中，libc位于/usr/lib/libc.a；在Windows上，Visual C++附带多个版本的C/C++运行库。以libc为例，glibc是用C语言开发的，和输入输出相关的有printf.o/scanf.o；和文件操作相关的有fread.o/fweite.o；和时间日期相关的有date.o/time.o等等。由于零散的目标文件非常杂乱，人们用ar压缩程序把它们压缩成libc.a这个静态库文件。

![](/assets/WpVMb6B7iorBdAxF68Wc9oZKnue.png)

用GCC的-verbose参数可以展示整个编译链接过程：

![](/assets/Ng5nbSjY5olfvHxSQfGcgbRanXe.png)

该链接过程至少包含了以下库和目标文件：

```c
crt1.o          crti.o          crtbeginT.o         libgcc.a
libgcc_eh.a     libc.a          crtend.o            crtn.o
```

---

## 动态链接

不难理解，静态链接会极大地浪费内存空间，并且第三方库的更新会导致原程序必须重新链接。于是动态链接出现了。它把链接这个过程推迟到了运行时。在动态链接的基本实现中，它把多个动态链接文件进行链接，而不是直接把目标文件做链接。在Linux中，ELF动态链接文件被称为 <b>动态共享对象（DSO）</b>，一般以".so"为扩展名；在Windows中，动态链接文件被称为<b>动态链接库（DLL）</b>，一般以".dll"为扩展名。

> 动态链接中的 <b>共享 </b>思想是它的核心思想，后续的实现细节也是基于保证动态链接能够通过 <b>共享 </b>来减小内存浪费来设计的

目标文件（这里特指可重定位文件）和动态链接文件是不同的概念，往往容易被混淆，其区别在于：

![](/assets/Z57YblrkKoo9lAxeqOCck85pnCf.png)

动态链接的示意图：

![](/assets/R0YsbtK50of3ZVxw5PScRlfknNb.png)

> 考虑到动态链接涉及到大量进程/虚拟地址相关操作系统的知识，大家可能还没学到，我尽量隐去相关细节

进程在运行时拥有完整的虚拟地址空间。其映射位于/proc/$pid/maps路径下。在里面可以查看进程的虚拟地址空间分布：

![](/assets/LpB6bDhI6o6qX4xQNUvcWABVnSb.png)

`Lib.so`是指定的共享对象文件，`libc-2.6.1.so`是C语言的运行库，`ld-2.6.1.so`是Linux下的动态链接器（可以发现动态链接器本身也是一个共享对象，这个在后面会详细介绍），`[stack]`是进程栈，`[vdso]`是和kernel通信的一个接口（不重要）

### 地址无关代码

地址无关技术是上文所提及的保证 <b>共享 </b>思想能够被实现的核心技术之一，可以说它是动态链接的骨架。

从概念上看：<b>地址无关代码（Position-Independent Code，简称 PIC）</b> 是一种技术，主要用于生成不依赖于固定内存地址的可执行代码，目的是使得代码能够在内存的任何位置加载并执行。它的核心思想是：<b>生成的代码不包含硬编码的地址引用，而是通过动态计算偏移来实现对内存中数据或指令的访问</b>，从而增强程序的灵活性、可重用性以及安全性。

当然，如果要使共享对象能够在任意地址装载，首先会想到重定位。但是静态链接中的重定位是在链接时候做的，在装载时已经太迟；因此有一种 <b>装载时重定位 </b>的技术，让共享对象在装载时由动态链接器对其符号进行重定位。

装载时重定位虽然能解决任意地址装载的问题，但是显然是不够好的。

设想一个具体场景，两个程序都用到了printf这个库函数，那么这个库根据动态链接的思想应该只被装载到内存中一份。但是printf在服务于两个不同进程的时候它的代码会有区别（最简单的例子就是当这个函数返回时，它的返回地址不同）。那么如果不做处理，操作系统必须要为每个进程独立地在虚拟地址空间中生成一份对应的指令副本，这和动态链接的想法显然是相悖的，没有实现节省空间这个功能。

为了实现地址无关代码，我们可以把 <b>共享模块中的地址引用按是否跨模块/是指令引用还是数据访问分为四类：</b>

- 模块内函数调用/跳转
- 模块内数据访问，如模块中定义的全局变量/静态变量
- 模块外函数调用/跳转
- 模块外数据访问，如其他模块定义的全局变量

#### 模块内调用或跳转/模块内数据访问

模块内的处理都是简单的。对于函数，机器都支持相对地址跳转，相对地址显然是已知的，故没有什么大问题（其实这种方式还存在一种共享对象全局符号介入的问题，后面再解释）

对于数据访问，由于任何指令和它需要访问的模块内数据的偏移也是固定的，可以用相对PC寻址找到对应数据

#### 模块间调用或跳转/模块间数据访问

这两种类型都通过引入大名鼎鼎的 <b>全局便宜表（GOT表） </b>来解决。GOT表往往与PLT表共同配合发挥作用，PLT表在后面会详细展开，这里就不详细介绍。<b>每个模块都有对应的GOT表和PLT表</b>。<b>GOT表内容的初始值指向PLT表，内容对应的下标是所有符号的占位符</b>。当模块A尝试访问定义在模块B中的变量`x`时，实际上会去访问`GOT[x]`，然后GOT表会跳转到PLT表，PLT表会把控制权交给动态链接器，让它去解析该符号的具体地址并填入GOT表的`GOT[x]`处。这样，后面A再去访问变量`x`时，都可以直接从GOT表跳转到`x`的实际位置。

> 以GOT表为跳板，就不需要OS把整个共享对象以副本的形式提供给进程了

<div class="flex gap-3 columns-2" column-size="2">
<div class="w-[50%]" width-ratio="50">
![](/assets/UYBabJAFPoQC33x3mZMcrmjAnnb.png)

</div>
<div class="w-[50%]" width-ratio="50">
![](/assets/SSUBbVImfoB11mxzZ9GcHEjrnGk.png)

</div>
</div>

这几种方式的解决方案其实并不能完全解决问题，还有比如 <b>共享模块的全局变量等问题 ，</b>涉及细节，在这里就不赘述了。

#### 数据段地址无关性

代码段能够运用PIC技术，那数据段呢？

其实稍微想想就知道，代码段是只读段，数据段本身就是可写段，在每个进程中都会有副本（这是不可避免的），因此PIC技术没有意义，只需对数据段做装载时重定位即可。

### 延迟绑定

很多函数在程序执行完时都不会被用到，比如一些错误处理函数或者是用户很少用到的功能模块等，如果一开始把所有函数链接好非常浪费时间。ELF使用PLT的方法来实现，动态链接器会调用函数解析函数地址，我们假设这个函数为`lookup()`，那么它需要的参数这个地址绑定发生在哪个模块，即`lookup(module,function)`。

PLT为了实现延迟绑定，在跳转到GOT到过程中加了一层跳转。每个外部函数在PLT中都有一个相应的项，比如`bar()`对应的地址称为`bar@plt`，其实现为：

```assembly
bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jump _dl_runtime_resolve
```

> `_dl_runtime_resolve`是Glibc中的`lookup()`实现

首次调用`bar()`时，为了实现延迟绑定，链接器在初始化阶段在GOT表填入的是`push n`的地址，相当于跳到GOT再跳回来。

注意到这个`n`其实是`bar`这个符号引用在重定位表`.rel.plt`的下标。`moduleID`就是模块的ID，接着`_dl_runtime_resolve`会完成符号解析和重定位，然后把`bar()`填入GOT表中。在接下来对`bar()`的调用直接走GOT表即可。

在PLT的真正实现中，ELF把GOT拆分成了两个表叫做`.got`和`.got.plt`，前者用来保存全局变量引用的地址，后者保存函数引用地址。对于后者来说，它的前三项有特殊意义：

1. `.dynamic`段地址
2. 本模块ID
3. `_dl_runtime_resolve()`地址

第二项和第三项是动态链接器负责初始化的，为了减少代码重复，ELF把上面例子中最后两个指令放到PLT中的第一项。

实际的PLT基本结构：

```assembly
PLT0:
push *(GOT + 4)
jump *(GOT + 8)

...

bar@plt:
jmp *(bar@GOT)
push n
jump PLT0
```

### `.interp`段

如何确定动态链接器的位置？它并不是由系统配置指定而是由ELF中的`.interp`段指定。里面保存的就是可执行文件所需要的动态链接器的路径。值得一提的是，这个路径指向的文件`/lib/ld-2.6.1.so`是一个软链接，系统会根据Glibc版本指向对应版本的动态链接器，如Glibc为2.6.1版本，它就会指向`/lib/ld-2.6.1.so`，可执行文件不需要改`.interp`来适应系统升级。

### `.dynamic`段

该段是动态链接过程中最重要的段。它存储了动态链接器所需要的基本信息，如依赖于哪些共享对象/动态链接符号表位置/动态链接重定位表位置/共享对象初始化代码地址等。其结构定义在`elf.h`中：

```c
typedef struct {
    Elf32_Sword d_tag;
    union {
        Elf32_Word d_val;
        Elf32_Addr d_ptr;
    } d_un;
} Elf32_Dyn;
```

其结构由一个类型值和一个附加的值或指针组成（Union类型共享内存）。根据类型的不同，后面的字段的含义也不同。

> `.dynamic`在功能上可以理解成静态链接时的ELF文件头

动态链接的符号表和重定位表大致和静态链接相似，区别过于涉及细节就不赘述。

### 动态链接的过程和实现

动态链接的步骤基本分为3步：

1. 启动动态链接器本身
2. 装载所有共享对象
3. 重定位和初始化

### 动态链接器自举

动态链接器本身也是一个共享对象，那么显然，它不能依赖于任何共享对象；且动态链接器本身需要的全局和静态变量的重定位工作由它本身完成。这个过程被称为自举（Bootstrap）

自举代码入口即动态链接器入口，它会先找到自己的GOT，然后找到`.dynamic`段，把动态链接器本身的重定位入口全部做重定位。此外，动态链接器也不能调用任何函数，自己的函数也不能调用。

有趣的是，在Glibc2.6.1的`elf.rtld.c`中，有一段注释：

> <b>Now life is sane</b>;we can call functions and access global data.Set up to use the operating system facilities, and find out fromthe operating system's program loader where to find the programheader table in core.Put the rest of  dl start into a separatefunction, that way the compiler cannot put accesses to the GOT before ELF_DYNAMIC_RELOCATE.

### 装载共享对象

自举后，动态链接器会把所有可执行文件和链接器本身的符号表合并，称为全局符号表。在`.dynamic`中，有一种类型入口是`DT_NEEDED`，它是指该文件依赖的共享对象。动态链接器会按某种算法遍历并装载所有共享对象，一般都是广度优先算法。当一个新的共享对象被装载时，它的符号表会被合并到全局符号表，当所有共享对象被装载时，全局符号表就会包含所有所需要的符号。

#### 符号优先级

如果有两个共享对象定义了同一个符号该怎么样链接呢？我们称一个共享对象里面的全局符号被另一个共享对象同名全局符号覆盖的现象时共享对象 <b>全局符号介入</b>。在Linux中，使用的是广度优先方法，如果相同的符号名存在，那么后加入的被忽略。

#### 全局符号介入与地址无关代码

由于全局符号介入的问题，地址无关代码技术会比我们前面讲的更复杂一些。对于第一类模块内部调用或跳转的处理时，我们不能简单地当成相对地址调用。由于可能存在全局符号介入的问题，所以编译器会把函数对全局变量的调用都当作模块外部符号处理。

如果要提高模块内部函数调用的效率，可以用`static`定义函数，这样编译器就会使用第一类方法编译。

### 重定位和初始化

接下来链接器会重新遍历重定位表并全部做修正。重定位完成后，如果共享对象有`.init`段，那么就会执行这个段中的代码进行初始化（比如C++的全局对象构造），对应的还可能有`.finit`，进程退出时会执行这个段中的代码（如进行C++析构等操作）

> 可执行文件中的初始化段不会由动态链接器执行，而是由程序初始化部分代码负责执行

### Linux动态链接器实现

Linux Kernel执行程序会把控制权交给程序入口，这个入口对于静态链接文件来说就是`e_entry`指定的入口；对于动态链接的可执行文件来说，就是`.interp`段中指定的地址。

Linux的ELF动态链接器时Glibc的一部分，源码位于Glibc的源码的elf目录下，实际入口是`_start()`函数。它的调用位于`elf/rtld.c`的`_dl_start()`函数，它先对`ld.so`做重定位，自举后调用`_dl_start_final`然后进入`_dl_sysdep_start`，接着进入`_dl_main`，这就是动态链接器的主函数。

---

如果大家对这方面有兴趣，欢迎来和我讨论！如果想看更多的细节和demo，也欢迎移步我的笔记：https://zephyriiiii.github.io/blog/%E8%AF%BE%E5%A4%96%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/Chapter1/

当然，阅读原书是更好的（原书写的确实生动具体有趣，非常好懂，提供了很多demo）。

