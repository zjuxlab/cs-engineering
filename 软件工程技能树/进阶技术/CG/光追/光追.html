<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-软件工程技能树/进阶技术/CG/光追/光追" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">光追 | CS-Engineering</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-test-site.com/cs-engineering/img/small-logo.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-test-site.com/cs-engineering/img/small-logo.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/cs-engineering/软件工程技能树/进阶技术/CG/光追/光追"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="光追 | CS-Engineering"><meta data-rh="true" name="description" content="Author: 章峥"><meta data-rh="true" property="og:description" content="Author: 章峥"><link data-rh="true" rel="icon" href="/cs-engineering/img/small-logo.svg"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/cs-engineering/软件工程技能树/进阶技术/CG/光追/光追"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/cs-engineering/软件工程技能树/进阶技术/CG/光追/光追" hreflang="zh"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/cs-engineering/软件工程技能树/进阶技术/CG/光追/光追" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/cs-engineering/blog/rss.xml" title="CS-Engineering RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/cs-engineering/blog/atom.xml" title="CS-Engineering Atom Feed"><link rel="stylesheet" href="/cs-engineering/assets/css/styles.4c83be5a.css">
<link rel="preload" href="/cs-engineering/assets/js/runtime~main.ff1670aa.js" as="script">
<link rel="preload" href="/cs-engineering/assets/js/main.c272b5bd.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/cs-engineering/"><div class="navbar__logo"><img src="/cs-engineering/img/small-logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/cs-engineering/img/small-logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">CS-Engineering</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/cs-engineering/新人必看CS工程指南介绍/gvpywcwokiqophkzxotckxylnld-gvpywc">知识空间</a><a class="navbar__item navbar__link" href="/cs-engineering/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/zjuxlab/cs-engineering" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cs-engineering/新人必看CS工程指南介绍/gvpywcwokiqophkzxotckxylnld-gvpywc">新人必看：CS工程指南介绍</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item software_engineering_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/cs-engineering/软件工程技能树/软件工程技能树">软件工程技能树</a><button aria-label="打开/收起侧边栏菜单「软件工程技能树」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed basic_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/基础入门/基础入门">基础入门</a><button aria-label="打开/收起侧边栏菜单「基础入门」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed frontend_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/前端技术/前端技术">前端技术</a><button aria-label="打开/收起侧边栏菜单「前端技术」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed backend_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/后端技术/后端技术">后端技术</a><button aria-label="打开/收起侧边栏菜单「后端技术」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed devops_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/运营维护/运营维护">运营维护</a><button aria-label="打开/收起侧边栏菜单「运营维护」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed tools_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/开发工具/开发工具">开发工具</a><button aria-label="打开/收起侧边栏菜单「开发工具」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item advanced_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/进阶技术">进阶技术</a><button aria-label="打开/收起侧边栏菜单「进阶技术」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/WEB3区块链/WEB3：区块链">WEB3：区块链</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/GUI开发Qt/GUI开发：Qt">GUI开发：Qt</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/量子计算/量子计算">量子计算</a><button aria-label="打开/收起侧边栏菜单「量子计算」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/CG">CG</a><button aria-label="打开/收起侧边栏菜单「CG」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/光栅化/光栅化">光栅化</a><button aria-label="打开/收起侧边栏菜单「光栅化」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/着色/着色">着色</a><button aria-label="打开/收起侧边栏菜单「着色」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/几何/几何">几何</a><button aria-label="打开/收起侧边栏菜单「几何」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item"><div class="menu__list-item-collapsible menu__list-item-collapsible--active"><a class="menu__link menu__link--sublist menu__link--active" aria-current="page" aria-expanded="true" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/光追/光追">光追</a><button aria-label="打开/收起侧边栏菜单「光追」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/光追/实现与优化/实现与优化">实现与优化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-5 menu__list-item"><a class="menu__link" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/光追/阴影/阴影">阴影</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-5 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/光追/渲染管道/渲染管道">渲染管道</a><button aria-label="打开/收起侧边栏菜单「渲染管道」" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-4 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/API/API">API</a><button aria-label="打开/收起侧边栏菜单「API」" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/客户端开发/客户端开发">客户端开发</a><button aria-label="打开/收起侧边栏菜单「客户端开发」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/大数据/大数据">大数据</a><button aria-label="打开/收起侧边栏菜单「大数据」" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cs-engineering/软件科研技能树/软件科研技能树">软件科研技能树</a><button aria-label="打开/收起侧边栏菜单「软件科研技能树」" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/cs-engineering/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/cs-engineering/软件工程技能树/软件工程技能树"><span itemprop="name">软件工程技能树</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/cs-engineering/软件工程技能树/进阶技术/进阶技术"><span itemprop="name">进阶技术</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/cs-engineering/软件工程技能树/进阶技术/CG/CG"><span itemprop="name">CG</span></a><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">光追</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>光追</h1><p>Author: 章峥</p><p>博客：<a href="https://zhzh2001.bitbucket.io/2022/11/09/learning-ray-tracing/" target="_blank" rel="noopener noreferrer">https://zhzh2001.bitbucket.io/2022/11/09/learning-ray-tracing/</a></p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">🎨</div><p>本文打算包含光线追踪与光栅化的差异、Whitted 风格光线追踪（Witted！）、BVH 加速等，如果有可能还想了解一下实时光线追踪的硬件加速（RTX！）以及路径追踪。</p></div><blockquote><p>图形学初学者（暑假才开始学），如有错误欢迎指正。</p></blockquote><h1><b>前言</b></h1><p>为什么选择光线追踪呢？一方面 RTX 使得其确实在这几年比较火，另一方面在今年 CPC 决赛题目就是优化 Blender Cycles 的渲染，其实就是光线（路径）追踪，虽然我们最近一直都在做降噪（denoise）。另外「汇编与接口」下一次 SIMD 实验我也打算优化朴素的光线追踪实现。</p><blockquote><p>P.S. CPC 无了，我们到最后还是没优化光追，降噪也一言难尽</p></blockquote><p>可能需要读者有一定的图形学基础。如果没有可以简单学一学 <!-- -->[GAMES101]<!-- -->(<u><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html" target="_blank" rel="noopener noreferrer">https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</a></u>)，非常推荐。至少可以过一下课件，如果有时间可以看 B 站课程视频。</p><p>本文基本上就是根据 GAMES101 光线追踪（基本原理、加速结构）的逻辑写的，后面的两讲就是路径追踪的高级内容，比较困难，不一定会写。大部分图片来自 GAMES101 课件，否则会标明来源。</p><p>对于来自 xlab 的读者：本文将会不断更新，最终会放到 wiki 上的，现在暂时先放链接。</p><p>我校的图形学课程也可以看看，我现在就在学，不过现在还没讲到着色和光线追踪。</p><h1><b>简介</b></h1><p>计算机图形学渲染通常可以分为实时渲染与离线渲染，实时渲染通常用在游戏中，离线渲染通常用在动画、特效等。实时渲染的渲染速度要求很高，因此通常使用光栅化（Rasterization）来渲染，而离线渲染则可以使用质量更好的光线追踪（Ray Tracing）来渲染。</p><ul><li><p>光栅化</p><ul><li><p>将场景中的物体投影到屏幕上，然后对每个像素进行着色。相当于是光源发出的光经过物体反射，直接进入了摄像机，就是直接光照。</p></li><li><p>优点：渲染速度快。</p></li><li><p>缺点：无法实现间接光照、全局光照、折射、折射等效果。</p></li></ul></li></ul><p><img loading="lazy" src="/cs-engineering/assets/images/LF7Fbob1TozaeyxFGjVcm66pnod-d2c1bb5608f078115b2ca44f72dc305f.png" width="1170" height="462" class="img_ev3q"></p><ul><li>以下是经典的 Blinn-Phong 模型：</li></ul><p><img loading="lazy" src="/cs-engineering/assets/images/CMDib7CCLotvyExSjFocA0DRnRd-2caac9a226ccaf3de03db09cee8d00b2.png" width="1163" height="371" class="img_ev3q"></p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">🥖</div><p>Bonus: 刚写好的 CG 作业，Phong shading，是比较怪的「混合」风格（固定管线属性+shader）</p></div><div class="language-openglshadinglanguage codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-openglshadinglanguage codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">varying vec3 position;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">varying vec3 normal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    position = gl_Vertex.xyz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    normal = gl_NormalMatrix * gl_Normal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gl_Position = ftransform();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="language-openglshadinglanguage codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-openglshadinglanguage codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// adapted from Phong vertex shader from 684 pp, Computer Graphics with OpenGL, 4th Edition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">varying vec3 position;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">varying vec3 normal;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">uniform vec3 viewPos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// fragment shader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec4 color = gl_FrontMaterial.ambient * gl_LightSource[0].ambient;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec3 n = normalize(normal);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vec3 lightDir = normalize(gl_LightSource[0].position.xyz);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    float nDotL = max(0.0, dot(n, lightDir));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    color += gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse * nDotL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (nDotL &gt; 0.0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vec3 v = normalize(viewPos - position.xyz);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vec3 r = reflect(-lightDir, n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        float rDotV = max(0.0, dot(r, v));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        color += gl_FrontMaterial.specular * gl_LightSource[0].specular * pow(rDotV, gl_FrontMaterial.shininess);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gl_FragColor = color;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><p>光线追踪</p><ul><li><p>从每个像素发出一条光线，然后计算光线与场景中物体的交点，然后计算交点的着色，并可以继续这个过程，直到光线消失或者达到最大追踪深度。</p></li><li><p>优点：可以实现更真实的光照效果。</p></li><li><p>缺点：计算量大，渲染速度慢。</p></li><li><p>以下是经典的 Whitted 模型：</p></li></ul></li></ul><p><img loading="lazy" src="/cs-engineering/assets/images/E9dQbt6kronFf1xO3oxcxGxSnNe-905d10ca443292626f3310ebbb15913a.png" width="1044" height="587" class="img_ev3q"></p><ul><li>路径追踪：综合光线追踪等多种技术，使用 Monte Carlo 方法来进行光线追踪，可以实现更真实的光照效果。</li></ul><p>我的理解是，一般说光线追踪，指的可能是 Whitted 风格这样的简单版本，也可能就是指路径追踪。</p><p>下图比较了光栅化、光线追踪、路径追踪的渲染效果（来源 <!-- -->[NVIDIA 博客]<!-- -->(<u><a href="https://blogs.nvidia.com/blog/2022/03/23/what-is-path-tracing/" target="_blank" rel="noopener noreferrer">https://blogs.nvidia.com/blog/2022/03/23/what-is-path-tracing/</a></u>)）：</p><p><img loading="lazy" src="/cs-engineering/assets/images/GJkJbyfwuoDbdkxxeXIcAeuInah-cccc0cd7204bdd6cac4628a42d6b524d.png" width="773" height="406" class="img_ev3q"></p><blockquote><p>想感受一下光线追踪的渲染过程？可以找个复杂的模型（最好是 PBR？）让 Blender 渲染看看（</p></blockquote><h1><b>Whitted 风格光线追踪</b></h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="基本原理"><b>基本原理</b><a href="#基本原理" class="hash-link" aria-label="基本原理的直接链接" title="基本原理的直接链接">​</a></h2><p>光沿直线传播，而且具有<b>光路可逆性</b>。正常情况下，光源发出一条光线，光线经过物体多次反射、折射，最终到达摄像机。然而，如果从光源向随机方向发出的光线，不太可能会到达摄像机，这样直接模拟的效率就很低。</p><p>因此，我们可以从摄像机发出「观察线」，其性质与光线完全相同，只是方向相反。当「观察线」与物体相交时，计算其与各个光源之间是否有遮挡，如果<b>没有遮挡</b>，则计算交点的着色，作为该像素的颜色。</p><p>这种方法称为「ray casting」，如下图所示：</p><p><img loading="lazy" src="/cs-engineering/assets/images/OTdqbOpv0oSfdAxLXuHcj491nGf-6fb8082ccc67cb2ed8d50686a132c962.png" width="1219" height="680" class="img_ev3q"></p><p><img loading="lazy" src="/cs-engineering/assets/images/HBZgbgU7LoLSHQx9f0Bcu73qn9g-d3b516984cf53452c1c6e4f47adf61f7.png" width="1002" height="721" class="img_ev3q"></p><p>「观察线」的方向就是摄像机与（透视投影）近平面上某个像素的连线，这样就可以计算出每个像素的颜色。也就是说，每个像素都需要发出一条「观察线」。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="递归追踪"><b>递归追踪</b><a href="#递归追踪" class="hash-link" aria-label="递归追踪的直接链接" title="递归追踪的直接链接">​</a></h2><p>上面的示意图只展示了一次反射的情况，和直接着色差不多。实际上光线追踪当然可以实现多次反射、折射等效果，只需要在计算交点的着色时，再发出一条「观察线」，然后递归地计算交点的着色即可。</p><p><img loading="lazy" src="/cs-engineering/assets/images/UYCtbVEuFoeD8rx4qJCcrv7EnJe-905d10ca443292626f3310ebbb15913a.png" width="1044" height="587" class="img_ev3q"></p><p>如图，「观察线」在球体上一分为二，分别进行了镜面反射和折射，然后再继续传播。可以注意到，除了从矩形到光源的连线被三角形遮挡外，其他的光线都没有遮挡，因此都需要参与着色计算。</p><p>另外，根据能量守恒，光线的总能量是不会超出初始值的，但可能发生能量损失，因此需要对能量进行衰减。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="效果"><b>效果</b><a href="#效果" class="hash-link" aria-label="效果的直接链接" title="效果的直接链接">​</a></h2><p>下图是 Whitted 风格光线追踪的效果：</p><p><img loading="lazy" src="/cs-engineering/assets/images/SnCEb6Dxno4lYJx8iaIcut8jn0c-c1eee653a23189f43d0c9e062f4fcc37.png" width="631" height="587" class="img_ev3q"></p><p>这就是当时 Whitted 用来展示光线追踪的图像，可以看到，折射、反射效果都很好，但是光线追踪的效率很低，因为每个像素都需要发出一条「观察线」。在当时的 VAX 11/780 上需要 74 分钟才能渲染出这张图。但在现代 GPU 上，完全可以实时渲染出这张图。</p><h1><b>数学表示</b></h1><p><img loading="lazy" src="/cs-engineering/assets/images/Fos8bjUpzoeqISxTDMUcFVaYnBh-a78ad9ef345e20310bd8429f1e9572ab.png" width="960" height="1078" class="img_ev3q"></p><p>来源：Wikipedia</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="光线"><b>光线</b><a href="#光线" class="hash-link" aria-label="光线的直接链接" title="光线的直接链接">​</a></h2><p><img loading="lazy" src="/cs-engineering/assets/images/PjsUb6FX8ohtsExFN3dcE23vnZd-c2bf9c85cc7d35bad48a3e45c0215d03.png" width="497" height="303" class="img_ev3q"></p><p>光线可以用射线来表示，由原点和方向向量组成。我们还引入参数 t，用来表示光线上的点。因此光线可以表示为</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">r</mtext><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mtext mathvariant="bold">o</mtext><mo>+</mo><mi>t</mi><mtext mathvariant="bold">d</mtext><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>t</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\textbf{r}(t) = \textbf{o} + t\textbf{d} \qquad (t \ge 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord textbf">r</span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord text"><span class="mord textbf">o</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">t</span><span class="mord text"><span class="mord textbf">d</span></span><span class="mspace" style="margin-right:2em"></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p><p>与隐曲面相交的点可以表示为</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">p</mtext><mo>=</mo><mtext mathvariant="bold">r</mtext><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\textbf{p} = \textbf{r}(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord textbf">p</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord textbf">r</span></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span></p><p>其中，隐曲面的方程为</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mtext mathvariant="bold">p</mtext><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(\textbf{p}) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord text"><span class="mord textbf">p</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span></span></p><p>这样就可以求解出 t，从而得到交点。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="平面"><b>平面</b><a href="#平面" class="hash-link" aria-label="平面的直接链接" title="平面的直接链接">​</a></h2><p>我们规定平面方程为</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext mathvariant="bold">p</mtext><mo>−</mo><msub><mtext mathvariant="bold">p</mtext><mn>0</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><mtext mathvariant="bold">n</mtext><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(\textbf{p}-\textbf{p}_0)\cdot\textbf{n} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord text"><span class="mord textbf">p</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord"><span class="mord text"><span class="mord textbf">p</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4444em"></span><span class="mord text"><span class="mord textbf">n</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span></span></p><p>其中，<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">p</mtext><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\textbf{p}_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6886em;vertical-align:-0.2441em"></span><span class="mord"><span class="mord text"><span class="mord textbf">p</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em"><span></span></span></span></span></span></span></span></span></span></span> 是平面上的一点，<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">n</mtext></mrow><annotation encoding="application/x-tex">\textbf{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em"></span><span class="mord text"><span class="mord textbf">n</span></span></span></span></span></span> 是平面的法向量。我们可以用这个方程来判断光线与平面的关系，如果光线与平面相交，那么光线上就存在点满足上面的方程。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="光线与三角形相交"><b>光线与三角形相交</b><a href="#光线与三角形相交" class="hash-link" aria-label="光线与三角形相交的直接链接" title="光线与三角形相交的直接链接">​</a></h2><p>在实际的应用中，很少用到参数曲面或隐曲面，一般（尤其是游戏中）都用<b>三角形（多边形）网格</b>来表示物体。因此，我们更关心光线与三角形（平面）相交的问题。</p><p>显然，光线所在的直线和三角形所在的平面除了平行就是相交，在实际中基本不可能是平行的。但要和三角形相交，交点就必须在三角形内，而且必须在光线的正方向上（<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span></span>）。</p><p>联立光线和平面方程，可以得到</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><msub><mtext mathvariant="bold">p</mtext><mn>0</mn></msub><mo>−</mo><mtext mathvariant="bold">o</mtext><mo stretchy="false">)</mo><mo>⋅</mo><mtext mathvariant="bold">n</mtext></mrow><mrow><mtext mathvariant="bold">d</mtext><mo>⋅</mo><mtext mathvariant="bold">n</mtext></mrow></mfrac><mspace width="2em"></mspace><mo stretchy="false">(</mo><mi>t</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t = \frac{(\textbf{p}_0-\textbf{o})\cdot\textbf{n}}{\textbf{d}\cdot\textbf{n}} \qquad (t \ge 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.3661em;vertical-align:-0.345em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0211em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord textbf mtight">d</span></span><span class="mbin mtight">⋅</span><span class="mord text mtight"><span class="mord textbf mtight">n</span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.4961em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord text mtight"><span class="mord textbf mtight">p</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1944em"><span style="top:-2.2341em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord text mtight"><span class="mord textbf mtight">o</span></span><span class="mclose mtight">)</span><span class="mbin mtight">⋅</span><span class="mord text mtight"><span class="mord textbf mtight">n</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:2em"></span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></p><p>判断交点是否在三角形内，比较容易想到的方法是计算交点与任意两点组成的三个三角形面积和是否等于原三角形面积。计算三角形面积可以用叉积。不过，计算量更小的方法是使用重心坐标。重心坐标的定义是</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">p</mtext><mo>=</mo><mi>α</mi><msub><mtext mathvariant="bold">p</mtext><mn>1</mn></msub><mo>+</mo><mi>β</mi><msub><mtext mathvariant="bold">p</mtext><mn>2</mn></msub><mo>+</mo><mi>γ</mi><msub><mtext mathvariant="bold">p</mtext><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">\textbf{p} = \alpha\textbf{p}_1 + \beta\textbf{p}_2 + \gamma\textbf{p}_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord textbf">p</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.8275em;vertical-align:-0.2441em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mord"><span class="mord text"><span class="mord textbf">p</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.9386em;vertical-align:-0.2441em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span><span class="mord"><span class="mord text"><span class="mord textbf">p</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6886em;vertical-align:-0.2441em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mord"><span class="mord text"><span class="mord textbf">p</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em"><span style="top:-2.4559em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>+</mo><mi>β</mi><mo>+</mo><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha + \beta + \gamma = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span>。我们可以用这个式子来判断交点是否在三角形内，如果交点在三角形内，那么 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo separator="true">,</mo><mi>γ</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\alpha, \beta, \gamma \ge 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span></span>，并且 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>+</mo><mi>β</mi><mo>+</mo><mi>γ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha + \beta + \gamma = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05278em">β</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.05556em">γ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span>。</p><p>将两步合并，就得到了一种高效的算法：</p><p><img loading="lazy" src="/cs-engineering/assets/images/TodObjH2yoAr0rxtu4OcoTsmncc-851b0ea18ed8a3152d2aed946aa18d7a.png" width="734" height="500" class="img_ev3q"></p><h1><b>加速结构</b></h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="必要性"><b>必要性</b><a href="#必要性" class="hash-link" aria-label="必要性的直接链接" title="必要性的直接链接">​</a></h2><p>通过上面的讨论，我们可以得到一种暴力的光线追踪算法：对于每一条发出的光线，与所有三角形求交，选择 t 最小的作为最近的交点。</p><p>即使每个像素只发出一条光线，时间复杂度也有像素数、反射次数和三角形数的乘积。在实际应用中，像素数和三角形数都非常多，因此这种算法的效率非常低。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="包围盒"><b>包围盒</b><a href="#包围盒" class="hash-link" aria-label="包围盒的直接链接" title="包围盒的直接链接">​</a></h2><p><img loading="lazy" src="/cs-engineering/assets/images/RDOJbTgTmoqTdXxM81ZchTXDn3b-73001be2922630dc9aa84fd9651655e6.png" width="1104" height="320" class="img_ev3q"></p><p>为了提高效率，我们可以使用<b>包围盒</b>（Bounding Box）来优化。顾名思义，包围盒将物体（或其一部分）的所有三角形包围在内，这样就可以快速判断光线是否与物体相交。如果光线没有与包围盒相交，那么肯定也不会与物体相交；如果光线与包围盒相交，再对三角形求交。</p><p>为了达到加速效果，包围盒与光线求交一定要尽量简单，采用比较广泛的是轴对齐包围盒（Axis-Aligned Bounding Box，AABB）。AABB 是一个立方体，而且每个面都与坐标轴平行。因此 AABB 需要 6 个参数来描述，例如 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">x</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em"></span><span class="mord mathnormal" style="margin-right:0.03588em">y</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.04398em">z</span></span></span></span></span> 的范围。</p><p>为了推导 AABB 与光线相交的算法，我们不妨将 AABB 看作三对「平行板」围成的体积。而光线要与之相交，必须存在一个时刻的点<b>同时位于三对平行板的内部</b>。而且这可以分开处理，如下图所示的二维情形：</p><p><img loading="lazy" src="/cs-engineering/assets/images/XjNwbmZHvoUTBjx2rF8cvQk6nQa-ac8c248f20fb5b5ba80c8f6655fb9f48.png" width="1272" height="583" class="img_ev3q"></p><p>推广到三维，对三个 t 范围联立，只要保证进入时间 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{in}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">in</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> 小于离开时间 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{out}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>，就可以判断光线与 AABB 相交。当然，由于射线的方向性，还需要判断 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">t_{out}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span> 是否大于 0。</p><p>AABB 还可以用于碰撞检测，其原理与光线追踪类似。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="均匀网格"><b>均匀网格</b><a href="#均匀网格" class="hash-link" aria-label="均匀网格的直接链接" title="均匀网格的直接链接">​</a></h2><p>将空间均匀分成三维网格，每个格子就是一个包围盒，包围盒中保存了所有<b>与其相交</b>的三角形（三角形可能跨网格）。这样，对于每条光线，只需要与「沿途」的网格中的三角形求交，就可以得到最近的交点。</p><p><img loading="lazy" src="/cs-engineering/assets/images/JWqubkwrGoszpMxc53xcv0Iznjc-af9c4f8334e5722ecc33e278a9e9bb8a.png" width="719" height="649" class="img_ev3q"></p><p>怎么确定「沿途」的网格呢？实际上，这和光栅化直线很类似。例如在上图中，光线的「斜率」在第一象限，因此下一个格子不是在右边就是在上面，if 一下就能找到。实际上有更加巧妙的画线算法，例如 Bresenham 算法，不需要分支就能快速计算出下一个格子。这里不再赘述，感兴趣的读者可以自行查阅。（GAMES101 似乎不讲，但是我校的 CG 课程有所展开，大概因为这些内容不太「现代」）</p><p>均匀网格实现很简单，但是网格大小是固定的，但是场景中物体的分布一般不均匀，因此会造成很多空网格和密集网格。这样就会造成很多不必要的计算。实际应用中，基本不会用均匀网格。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="基于空间的分割"><b>基于空间的分割</b><a href="#基于空间的分割" class="hash-link" aria-label="基于空间的分割的直接链接" title="基于空间的分割的直接链接">​</a></h2><p><img loading="lazy" src="/cs-engineering/assets/images/FIkIbXRnKojeTTxisMPcdEM2noh-abe465ee3474bf557d73183e239e4ff2.png" width="1177" height="509" class="img_ev3q"></p><p>既然均匀分割不太好，那么我们可以根据物体的分布来分割空间。这样的方法包括八叉树、KD 树、BSP 树等。这些方法都是每次将空间分成两部分，最终形成树状结构。</p><p>注意一个三角形可能会<b>跨越多个区域</b>，因此要尽量减少切割面分割三角形，否则最终会产生远多于初始的三角形数量（如果切割面斜着分割三角形，会产生一个三角形和一个四边形，相当于三个三角形），降低效率。三角形保存在叶节点。</p><p>另一个问题是如何确定分割的规则，这还是比较困难的。对于没有物体的区域，显然可以停止分割；但对于有物体的区域，分割到什么程度才算合适，没有一个明确的标准。八叉树、KD 树和 BSP 树对每次分割的规则不同，八叉树要求最严格，BSP 树要求最宽松，而 KD 树则介于两者之间。</p><p>以 KD 树为例，每次分割都与坐标轴平行。下图展示了使用 KD 树加速光线追踪的过程：</p><p><img loading="lazy" src="/cs-engineering/assets/images/B5zZb7EtnoBSDyxu8CKcmzb7nVc-de601aa652d19aa478d59742032c43d9.png" width="1182" height="710" class="img_ev3q"></p><p>对于光线途径的每个叶节点，都需要与其中的三角形求交。在图中的例子中加速效果看起来不明显，但当树的深度较大时，加速效果就很明显了。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="bvh"><b>BVH</b><a href="#bvh" class="hash-link" aria-label="bvh的直接链接" title="bvh的直接链接">​</a></h2><p><img loading="lazy" src="/cs-engineering/assets/images/PUxXbTjBtofIDix9DQccauSenMd-2650981a175c13bddc59621fb217b5a6.png" width="1200" height="539" class="img_ev3q"></p><p>与上述基于空间的分割不同，BVH 是基于物体的分割。BVH 的全称是 Bounding Volume Hierarchy，即包围盒层次。在构建 BVH 树的过程中，每次将物体分成两部分，并<b>重新计算包围盒</b>，最终形成树状结构。</p><p>注意现在一部分空间可能属于多个包围盒，也就是说，包围盒之间可能有交集。三角形还是保存在叶节点。</p><p>BVH 的分割规则也没有定论，可以采用的启发式规则包括选择最长的轴分割，每次分割两边的物体数量接近，当物体很少时不再分割等。</p><p>BVH 的遍历和上面类似，不再赘述。下图总结了基于空间和基于物体的分割的区别：</p><p><img loading="lazy" src="/cs-engineering/assets/images/KSIbbfiZ7otoQcxcoLucoTzinhf-65defe25e875a9209eee5c4a54ba3813.png" width="1163" height="688" class="img_ev3q"></p><p>此外，在我校 CG 进阶课程，讲 BVH 优化的课上（因为 CPC 去看的），介绍了高级的 BVH 构建方法。</p><p><img loading="lazy" src="/cs-engineering/assets/images/WhqWbXzdioA1hGxvJ98cR6chnmI-b5056e6a797ca29394c700f6c82e17b5.png" width="1609" height="663" class="img_ev3q"></p><p>基于包围盒面积的命中概率估计来选择最优的分割点。尽可能最小化分割后包围盒的面积和，这样可以减少遍历的节点数量。</p><p><img loading="lazy" src="/cs-engineering/assets/images/Gjx3beLUNoBClPxwPczcNj2Sncn-df7abdefad42d52d8c51c3e5b2af23d1.png" width="1154" height="523" class="img_ev3q"></p><p>将基本形状视为点来完成分割。</p><p><img loading="lazy" src="/cs-engineering/assets/images/GNBdbi1wWolOqNxGbx6cN82Wnic-20c01e1e5073a8132d30ca5f4695fd49.png" width="1490" height="297" class="img_ev3q"></p><p>使用贪心算法，认为每次选择最优的分割点，最终得到的树是接近最优的。</p><blockquote><p>从下面的内容开始，就不是传统 CG 课程的内容啦！</p></blockquote><h1><b>实时光线追踪*</b></h1><p>可先行阅读 <u><a href="https://www.anandtech.com/show/13282/nvidia-turing-architecture-deep-dive" target="_blank" rel="noopener noreferrer">https://www.anandtech.com/show/13282/nvidia-turing-architecture-deep-dive</a></u></p><ul><li>anandtech 是一个非常好的网站，保存了从 1997 年成立以来各种 CPU、GPU 和其他 PC 硬件的评测文章，非常适合考古。</li></ul><blockquote><p>P.S. Tom&#x27;s Hardware 成立时间也类似，也能找到很好的早年评测文章</p></blockquote><p><img loading="lazy" src="/cs-engineering/assets/images/PesEbK1qOo3KxZxawi0cUqzEnZf-7f17f474c65edf2f78d53b4f8c8e1f8b.jpeg" width="2736" height="1536" class="img_ev3q"></p><p>我看了一圈，感觉和 Tensor Core / DLSS 比起来，RT Core 的资料实在是太少了。NVIDIA 给出的官方资料就不多，而且这类 ASIC 设计似乎也不是很吸引人。而且似乎还是 RTX 20 系发布时报道多一点，大概是后来大家都无所谓了。因此接下来基本上简单总结一下 anandtech 的文章内容。</p><p><img loading="lazy" src="/cs-engineering/assets/images/MmukbM1iNoBniAxTbFkchVWlnbh-486a81cd7dfc732b1096216a590e2883.png" width="4000" height="2250" class="img_ev3q"></p><p>BVH 是目前光线追踪的主流，实时光线追踪用的也是 BVH，只不过 BVH 的构建和遍历都是在 GPU 上完成的。上图更加生动的展示了 BVH 的结构。</p><p><img loading="lazy" src="/cs-engineering/assets/images/CSEzb0LGwo4jDgxno25cQuExnjf-f53cd649f0ca4e0d175095727928aff3.png" width="4000" height="2250" class="img_ev3q"></p><p>传统上，用 GPU 的可编程 shader 来软件模拟光线追踪，其效率可能高于 CPU，但可能难以到达实时的水平。追踪每条光线可能需要上千条指令来完成。因此硬件加速就显得很有必要，尤其是认为光线追踪是未来主流的 NVIDIA。</p><p><img loading="lazy" src="/cs-engineering/assets/images/L9NhbptBfoKTQixnNJwciRWKnMd-5a80da1113f65125b0702fbc3a9b0292.png" width="4000" height="2250" class="img_ev3q"></p><p>因此，RT Core 就是把计算量最大的部分，即光线遍历和求交的计算，放到了特殊的硬件上。不过，光线追踪的空间局部性并不好，对于内存带宽是一个挑战。</p><h1><b>路径追踪*</b></h1><blockquote><p>我暂时放弃了，看到 Rendering Equation 感觉就很假了（</p></blockquote><p>可以看 <u><a href="https://www.youtube.com/watch?v=gsZiJeaMO48" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=gsZiJeaMO48</a></u> 直观感受一下。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/软件工程技能树/进阶技术/CG/光追/光追.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/cs-engineering/软件工程技能树/进阶技术/CG/几何/摄像机与坐标变换/四元数基础/ 四元数基础"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label"> 四元数基础</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/cs-engineering/软件工程技能树/进阶技术/CG/光追/实现与优化/实现与优化"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">实现与优化</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基本原理" class="table-of-contents__link toc-highlight"><b>基本原理</b></a></li><li><a href="#递归追踪" class="table-of-contents__link toc-highlight"><b>递归追踪</b></a></li><li><a href="#效果" class="table-of-contents__link toc-highlight"><b>效果</b></a></li><li><a href="#光线" class="table-of-contents__link toc-highlight"><b>光线</b></a></li><li><a href="#平面" class="table-of-contents__link toc-highlight"><b>平面</b></a></li><li><a href="#光线与三角形相交" class="table-of-contents__link toc-highlight"><b>光线与三角形相交</b></a></li><li><a href="#必要性" class="table-of-contents__link toc-highlight"><b>必要性</b></a></li><li><a href="#包围盒" class="table-of-contents__link toc-highlight"><b>包围盒</b></a></li><li><a href="#均匀网格" class="table-of-contents__link toc-highlight"><b>均匀网格</b></a></li><li><a href="#基于空间的分割" class="table-of-contents__link toc-highlight"><b>基于空间的分割</b></a></li><li><a href="#bvh" class="table-of-contents__link toc-highlight"><b>BVH</b></a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cs-engineering/docs/intro">Tutoria</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cs-engineering/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/zjuxlab/cs-engineering" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 浙江大学启真交叉学科创新创业实验室, Inc.</div></div></div></footer></div>
<script src="/cs-engineering/assets/js/runtime~main.ff1670aa.js"></script>
<script src="/cs-engineering/assets/js/main.c272b5bd.js"></script>
</body>
</html>