<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-软件工程技能树/进阶技术/量子计算/量子计算" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">量子计算 | CS-Engineering</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://your-docusaurus-test-site.com/cs-engineering/img/small-logo.jpg"><meta data-rh="true" name="twitter:image" content="https://your-docusaurus-test-site.com/cs-engineering/img/small-logo.jpg"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/cs-engineering/软件工程技能树/进阶技术/量子计算/量子计算"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="量子计算 | CS-Engineering"><meta data-rh="true" name="description" content="Author：符一笑"><meta data-rh="true" property="og:description" content="Author：符一笑"><link data-rh="true" rel="icon" href="/cs-engineering/img/small-logo.svg"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/cs-engineering/软件工程技能树/进阶技术/量子计算/量子计算"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/cs-engineering/软件工程技能树/进阶技术/量子计算/量子计算" hreflang="zh"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/cs-engineering/软件工程技能树/进阶技术/量子计算/量子计算" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/cs-engineering/blog/rss.xml" title="CS-Engineering RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/cs-engineering/blog/atom.xml" title="CS-Engineering Atom Feed"><link rel="stylesheet" href="/cs-engineering/assets/css/styles.4c83be5a.css">
<link rel="preload" href="/cs-engineering/assets/js/runtime~main.ff1670aa.js" as="script">
<link rel="preload" href="/cs-engineering/assets/js/main.c272b5bd.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/cs-engineering/"><div class="navbar__logo"><img src="/cs-engineering/img/small-logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/cs-engineering/img/small-logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">CS-Engineering</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/cs-engineering/新人必看CS工程指南介绍/gvpywcwokiqophkzxotckxylnld-gvpywc">知识空间</a><a class="navbar__item navbar__link" href="/cs-engineering/blog">博客</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/zjuxlab/cs-engineering" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/cs-engineering/新人必看CS工程指南介绍/gvpywcwokiqophkzxotckxylnld-gvpywc">新人必看：CS工程指南介绍</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item software_engineering_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/cs-engineering/软件工程技能树/软件工程技能树">软件工程技能树</a><button aria-label="打开/收起侧边栏菜单「软件工程技能树」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed basic_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/基础入门/基础入门">基础入门</a><button aria-label="打开/收起侧边栏菜单「基础入门」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed frontend_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/前端技术/前端技术">前端技术</a><button aria-label="打开/收起侧边栏菜单「前端技术」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed backend_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/后端技术/后端技术">后端技术</a><button aria-label="打开/收起侧边栏菜单「后端技术」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed devops_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/运营维护/运营维护">运营维护</a><button aria-label="打开/收起侧边栏菜单「运营维护」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed tools_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/开发工具/开发工具">开发工具</a><button aria-label="打开/收起侧边栏菜单「开发工具」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item advanced_sidebar"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/进阶技术">进阶技术</a><button aria-label="打开/收起侧边栏菜单「进阶技术」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/WEB3区块链/WEB3：区块链">WEB3：区块链</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/GUI开发Qt/GUI开发：Qt">GUI开发：Qt</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible menu__list-item-collapsible--active"><a class="menu__link menu__link--sublist menu__link--active" aria-current="page" aria-expanded="true" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/量子计算/量子计算">量子计算</a><button aria-label="打开/收起侧边栏菜单「量子计算」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/量子计算/量子信息基础/量子信息基础">量子信息基础</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/CG/CG">CG</a><button aria-label="打开/收起侧边栏菜单「CG」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/客户端开发/客户端开发">客户端开发</a><button aria-label="打开/收起侧边栏菜单「客户端开发」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/cs-engineering/软件工程技能树/进阶技术/大数据/大数据">大数据</a><button aria-label="打开/收起侧边栏菜单「大数据」" type="button" class="clean-btn menu__caret"></button></div></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/cs-engineering/软件科研技能树/软件科研技能树">软件科研技能树</a><button aria-label="打开/收起侧边栏菜单「软件科研技能树」" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/cs-engineering/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/cs-engineering/软件工程技能树/软件工程技能树"><span itemprop="name">软件工程技能树</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/cs-engineering/软件工程技能树/进阶技术/进阶技术"><span itemprop="name">进阶技术</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">量子计算</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>量子计算</h1><p>Author：符一笑</p><p>有可能你听说过量子计算，有可能不但听过而且自己了解过一些，甚至可能有的专业学这门课，不管对于量子计算了解多少，大多数时候对量子计算恐怕都是一种“无关心”的状态。</p><p>本文就尝试使读者认同了解量子计算的意义，无论读者身份是计算机专业的，物理专业的，或者就不管身份得作为一般的人。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="spoiler">Spoiler<a href="#spoiler" class="hash-link" aria-label="Spoiler的直接链接" title="Spoiler的直接链接">​</a></h2><p>写作本文的知识搜集和思想工作在两个月中断断续续地进行，所以有所不连贯和错漏在所难免。加上即使在写推广量子计算的文章，我也可以大方承认，不了解量子计算确实<b>没什么损失</b>，花时间去看一篇可能有错的文章净亏一个钟头。所以，有必要在开头写明这文章到底有什么货了。</p><ul><li>介绍<b>Shor算法</b>，展示量子计算的强大和巧妙</li><li>探讨量子计算的思路在各种场景中可以发挥何种效用</li><li>提供量子计算应用的开放性例子供读者思考和研究</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="shor-算法">Shor 算法<a href="#shor-算法" class="hash-link" aria-label="Shor 算法的直接链接" title="Shor 算法的直接链接">​</a></h2><p>如果要向没听说过量子计算的人吹嘘量子计算，十有八九会选择秀尔算法。因为他就够巧妙和够有影响力。你可能没听说过它的创始人<b>Peter Shor </b>但是你肯定听过素因数分解问题（Integer Factoring Problem，也叫做大素数分解，因数分解问题），而“IFP”无法被有效解决更是RSA密码体系的重要基础。IFP属于NP问题（准确来讲，是NP-intermediate），在量子计算问世之前，IFP就固若金汤，两千位的自然数就是用上大量计算资源并行地跑也需要无法接受的时长，于是银行卡，各种电子账户安全，比起从密码学角度暴力破解密码体系不如直接趁别人输密码偷看成功率高。</p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">🍻</div><h3>P&amp;NP</h3><p>ads课会详细介绍什么是P和NP，这里粗暴一点讲的话：</p><ul><li><p>P问题就是可以在多项式时间确定解决的问题</p></li><li><p>NP问题可以在多项式时间验证给定解的正确性，不过不一定可以在多项式时间找到解</p></li><li><p>目前没有人能证明或者证伪NP和P是否等价，这是个悬赏问题</p></li><li><p>有一类特别的NP问题叫NP-complete（NP完全问题），所有NP问题都可以在多项式时间内转化为解决一个完全问题，所以假如任何一个完全问题在多项式时间内得解，所有NP问题就都可以，这意味着NP=P。假如能做到这点，你就是计算机学和数学的英雄，以及，额，银行卡安全的最大敌人。</p></li></ul></div><b>经典计算机解决不了不代表量子计算机不行</b>（该记住的重要直觉），秀尔算法就把IFP侮辱，<b>用多项式时间</b>解出它的答案。<p>你可能要问，那么NP对P问题不是解决了吗，答案是没有。IFP目前没有传统方法多项式时间解，所以它属于NP而在P之外。在NP这个圈子里IFP的地位也比较特殊，所谓”Intermedia“，指的是IFP既不是P问题又不是NP-complete问题（至少现在两边也都没人可以证明它是）。所以解决一个IFP并不能解决所有NP问题。（其实一会会看到，Shor算法是概率成功的，所以退一步讲，本身都不能算P，也就不能使所有NP变成P）</p><p>你可能又要问，就算就解决不了NP对P，那RSA不是完蛋了吗，银行卡是否不安全了。答案又是没有，原因是现实世界的量子计算机太弱，在概念抽象中的量子计算机（分析时一般作为“oracle/神谕”考虑）无论有多强大都是假的，在现实中，所谓“量子计算机”称为“物理实验”更合适，量子计算里那些“门”可能会变成电容，”量子比特“可能会变成简谐波，乱七八糟的纠缠和叠加干扰更是难以避免。回到IFP的例子，现在的量子计算机最多支持<code>15=5*3</code> 这种程度的分解，拿两千位的自然数一点办法没有，所以，银行卡还是安全的。</p><p> 说了这么多，不难感受到Shor算法的以及IFP问题的敏感性，有人把Shor算法称为量子算法的皇冠，而更令人不得不品尝的原因还有其原理的简洁。</p><p>功克IFP分两部分，前半只是简单的数学，后半则是巧妙的量子计算，也就是Shor算法。而作者就有自信让读者今天学会这个有名的算法。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="经典部分">经典部分<a href="#经典部分" class="hash-link" aria-label="经典部分的直接链接" title="经典部分的直接链接">​</a></h3><p>正式看看IFP的定义</p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">👀</div><p><em>IFP可能有不少变形，这里取一种定义</em></p><p>IFP问题： <b>对正整数N求其素分解</b></p></div><p>而我们的目标就是设计一个算法来在多项式时间求出这个素分解。由于问题的背景，N一般很大。</p><p>拿到问题，第一个考虑就是我们是否要老实输出N的所有素数因子，在不破坏时间复杂度的前提下能否等价转换这个问题。</p><p>答案是可以的，注意到IFP的递归性质，事实上，能足够快（多项式内）地求出<b>一个因子</b>就能在多项式内求出所有素因子。</p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">😲</div><p><b>HOW？</b></p><p>答案是小学数学，假如求出了N的一个因子a，那原素分解可以通过求a和N/a的素分解，然后把结果合起来直接得到。如此展开，求解过程会形成一棵树，每个结点代表“求解当前结点的素分解”。</p><p>考虑叶子节点代表什么，由于叶子分无可分，所以叶子上一定是素数，这些素数合起来就是N的素分解，即使因子全部是自然数2（最小的素数），N也只能拥有log2（N）个叶子。</p><p>到了这步有必要的话可以列个方程，由于每个内部结点必有两个孩子，叶子至多log2（N）个，解得所有结点至多有2*log2（N）个。由于假设了根节点可以在多项式时间内拆分，即使剩下结点用时全部按照最长的根结点来算，代价还是在多项式内。</p></div><p>问题变形到到这一步，有一个经典范畴的”筛法“，同样可以解决IFP，事实上这个叫 general number field sieve(GNFS) 的算法就是经典范畴的最优；它的复杂度是：</p><p><img loading="lazy" src="/cs-engineering/assets/images/CYW9b1mcDoSGp2xJbdSczQ6wnO2-d212013dd2a7b633fdfd1995123dc6bc.png" width="1196" height="221" class="img_ev3q"></p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">🍤</div><p><b>什么是“多项式时间”</b></p><p>在讨论NP问题时，”多项式时间“的定义要向NP完全问题看齐，特别地，这个NP完全问题一般是<b>SAT/布尔可满足问题</b>（简单来说就是给定命题判断n个布尔变量如何取值可以使之成立，没有好思路之前，显然会花费指数时间）</p><p>换句话说，问题的规模要转化成二进制来考虑。在IFP的例子中，N可以表示成log2（N）位二进制数，所以问题的规模其实是log2（N），而不是N。所以，所谓多项式时间是<b>对数</b>的多项式（现在你会注意到HOW模块里面的放缩刚刚好）</p></div><p>上面的式子是lnN的指数，所以就如我们提到的一样，经典算法没有多项式代价的。顺便一提，GNFS的处理能力大约是400bit，所以正式使用的加密需要两千多位防止力大砖飞。</p><p>回到IFP，我们其实可以进一步简化我们的目标。事实上，我们不必直接求N的一个因子，而可以求和N<b>共因子</b>的任意整数（当然，共因子不能是共“N”这样共法），原因是我们有欧几里得算法。</p><p>欧几里得算法又叫辗转相除法，可以很快地求两个数的公共因子，在得到和N共因子整数之后就对其使用欧几里得算法求出共因子。它的代价不超过多项式，而且又是串行步骤，所以不影响最终代价。</p><p>目前的转换都是“无损耗的”，但是接下来的一步转换不是完全等价的。</p><p>注意到，假设我们找到的a满足a和N共因子b，也就是：a=b<em>c,N=b</em>d ， </p><p>变形得到：d<em>a=c</em>N</p><p>所以当我们求a时，我们其实求得的是c*N的一个因子。由于k的随意性，c也跟着是随意的，所以原问题变成了：</p><p>给定整数N,求 c*N 的任何一个因子，其中c是任意整数</p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">🍋</div><p>目前我们的完整任务转变</p><p><b>-&gt;对正整数N求其素分解</b></p><p><b>-&gt;求N的任意因子</b></p><p><b>-&gt;求任意和N共因子的整数</b></p><p><b>-&gt;求 c*N 的任何一个因子，其中c是任意整数</b></p><p>其中最后一步不是“总成立”的，原因是c*N的因子很可能带c或者N，这样的因子就没有用了，不过幸运的是，之后我们会看到，这种失败的概率可以控制</p></div><p>下面就是去找这个因子了，我们从猜解开始。</p><p>首先不妨碰碰运，<b>随机</b>（只有当第一猜随机时后面的成功率才有保证）猜想一个因子g。</p><p>结果如何？假如运气足够好，用欧几里得算法之后发现了他们的（非1）公因子，那么一步就解决了问题，可喜可贺。但是，大多数时候，我们都会遗憾猜错,也就是：</p><p>gcd(N,g)=1</p><p>现在可以抛弃g，再猜一次，没有问题，但是这样绝对会超出多项式时间。我们要想办法<b>把错解变成一个更有可能成功的解</b>。看看手头的条件，虽然猜解失败了，但是我们得到了N，g互素的额外条件，至于“互素”就暗示了g在N的除环上很可能有好性质。</p><p>而在这个问题中确实是有的，那是一个称为欧拉定理的数学事实：</p><p><img loading="lazy" src="/cs-engineering/assets/images/SboLbsqxRodnHjxO9JecGhJlnJe-f85ac3dbb7b25c96e71257554a375997.png" width="666" height="63" class="img_ev3q"></p><p>式子里的<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></span>叫做欧拉函数或者瞬变因子，它的值等于<b>比b小的所有整数中和b互素的数的个数</b></p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">😗</div><p>如果你够敏感，你会发现这个定理形式和费马小定理很像。其实，小定理就是欧拉定理的特殊情况，当b本身是素数，所有比b小的数都和b互素，于是瞬变因子就是b-1，代入就得到小定理</p><p>欧拉定理的证明只需要一点抽代知识，闲的时候不妨尝试自己证一下</p></div><p>很可惜的是，我们不能通过求瞬变因子来优化g，因为求N的瞬变因子要确定N以下的N-1个数是否和N互素，而只要找到一个不是和N互素且小于N的数，我们分解N的目的其实就直接达到了。所以求瞬变函数是比IFP强的问题，不能指望从这个方向攻克。</p><p>解决的方法还是猜解，不过需要用量子计算来猜，如何猜出这个合适的指数就是下半节，或者说Shor算法的精髓了。</p><p>不过在进军量子领域之前，还是让我说明一下怎么利用<b>猜出来</b>的指数得到解。</p><p>假设我们已经找到了某个指数p使得：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>p</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>N</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mn>1</mn></mrow><annotation encoding="application/x-tex">g^p mod N = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mord"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord"> </span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mord"> </span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord"> 1</span></span></span></span></span></p><p>移项，也就是<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>p</mi></msup><mtext> </mtext><mo>−</mo><mn>1</mn><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>c</mi><mo>∗</mo><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">g^p -1 = c* N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mord"> </span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1 </span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.4653em"></span><span class="mord"> </span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord"> </span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span></p><p>利用平方差公式得：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>g</mi><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><msup><mi>g</mi><mrow><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">(g^{p/2}-1)*(g^{p/2}+1)=c*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mtight">/2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mtight">/2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.4653em"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span></p><p>仔细观察，右边就是我们任务变形后得到的 c*N ,而左边的两个数就是N的候选因子。当然，要从候选变成真正的解前提还得是p是偶数，这里又引入一个<b>可能失败</b>的地方，加上前面的最后一步<b>不严格转换</b>；在g完全随机的情况下大约有<b>62.5%</b>的失败率。</p><p>在重复实验下，次次失败的概率会指数收敛到零，所以只要重复几次，总能成功的（尤其是在同时破解一大批密码的时候，成功率会非常稳定），而一旦成功找到了因子，就相当于解决了IFP，也就破解了比如一张银行卡的加密。</p><p>收尾结束，接下来就是量子部分。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="量子部分">量子部分<a href="#量子部分" class="hash-link" aria-label="量子部分的直接链接" title="量子部分的直接链接">​</a></h3><p>经典推导的最后留下了一个“求合适指数”的问题，只要能足够快地得到这个指数，原问题就间接得解。求解这个合适指数就是Shor算法的任务；大体上讲，Shor算法利用了两次量子傅里叶变换，以及一个<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>x</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>N</mi></mrow><annotation encoding="application/x-tex">g^x mod N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mord"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord"> </span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span>的函数门，最后巧妙地使正确答案的信号概率加强，最终解出这个指数。</p><del>如果有条件，希望先通过隔壁的文章对量子计算有个初步印象。</del><p>考虑到没时间了解细节知识的情况，这里亦有一些快餐式的介绍，方便起见，部分表述可能未必严格，不过都会提供有益的直觉。</p><p>如果用一句话阐述量子计算，那就是<b>另一种概率论</b>。量子计算就是研究概率和利用概率产生预期结果的学问。与经典概率不同，量子计算里的概率（probability amplitude）表现更加多样，比如交叉项，负概率，复数概率，都是其经典特征。这些概率的<b>外显</b>就是我们（相对）熟悉的纠缠，叠加，干涉等等的物理现象。</p><p>说得玄乎，我们通过“量子比特”的概念直观感受一下，量子计算和传统计算的不同。</p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">😗</div><p><b>量子比特（Qubit）</b></p><p>量子比特是物理对象的概念抽象。凡是有两个状态的物理对象（有高低能级的原子，简谐波...）都可以视作量子比特，并且可以用来实现量子路（quantum circuit）。</p><p>一般把低态用 |0&gt; 表示，高态用 |1&gt;表示，一个量子比特可以用两者的和式表示，例如 a|0&gt; + b|1&gt; 这样子。</p><p>a和b就代表了概率强度，当对这个量子比特“观测”时，它会以|a^2|概率得到低态，或者以|b^2|概率得到高态。（由于概率归一，系数模的平方和要是1）</p></div><p>且不管量子计算背后的物理原理，量子计算的流程往往是这样：</p><ul><li>首先，产生一批候选解的叠加</li><li>然后，通过一系列量子门让错误的解彼此相消</li><li>最后，进行观测，让结果大概率“坍缩”成我们希望的解</li></ul><p>我们接下来的算法也遵照这个流程。</p><p>现在离准备好迎接我们的算法还差一个“量子门”的概念。简单点讲，量子门就是对一个量子比特或者很多个量子比特进行运算的元件。类比经典门，比如说或与非，也有这样一批基本量子门，只通过他们就可以组合（逼近）任何量子门（unitary operation），抛开底层原理，量子门的表现就好比<b>矩阵乘</b>，过路的量子比特都要被做一次矩阵运算。你可能已经猜到了，量子比特就可以写成向量形式，例如|0<!-- -->&gt;<!-- -->就是<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(1,0)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">0</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em">T</span></span></span></span></span></span></span></span></span></span></span></span>，|1<!-- -->&gt;<!-- -->就是<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">(0,1)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em">T</span></span></span></span></span></span></span></span></span></span></span></span>。</p><p>是时候了，我们便一览Shor算法的量子通路。</p><p><img loading="lazy" src="/cs-engineering/assets/images/GF0ybxdylo2iIkxp667cga3bnte-31c09acb00e7afbc6d94351f451beec6.png" width="1097" height="513" class="img_ev3q"></p><p>对于图例我们一一解释他们的含义：</p><ul><li>图中的每条横线表示一个量子比特，你可以注意到这样的横线有很多条而且分成上下两组，这是因为要完成我们的计算目标需要多个量子比特。</li><li>图中的方框代表量子门，最下方的门已经把具体运算写在了上面，上方两个门的F代表“量子傅里叶变换”，稍后会给出介绍</li><li>图中的竖线表示了某种“信息”在下路和上路之间传递，这样的信息经过精巧设计，最终服务于让我们不需要的解相消，这种技术叫做 ”function evaluation“，它的效果是产生一种” phase kickback “的效果来作用于上路的量子比特们</li></ul><p>熟悉了图中的元素，接下来就看这样的量子路如何求出我们想要的指数p吧。</p><p>Shor算法的精妙之处大概可以分成这几个部分：</p><ul><li>利用第一个量子傅里叶变换，将纯基态输入转化为<b>所有长为n的二进制串的等概率叠加</b>（这是量子计算一个非常强大的功能，在量子算法应用的讨论里会再次提及）</li><li>利用下方的函数门对另一组基态输入做操作，并且观察其结果。这里的函数门输出和上路的量子比特状态密切相关，所以当观测完成之后，信息会反向传回上路，使上路从所有二进制串的叠加变为满足某种性质的串的叠加</li><li>最后一道量子傅里叶变换门会发挥频率分析的作用，从“滤波”之后的上路求解出一个特征频率。这个频率的倒数就是我们所求的指数p</li></ul><p>你可能好奇这几个量子门内部结构是怎么样的，但是除了告诉你它们可以由许多很小的基本门拼起来以外，本文不打算作详细解释（吊胃口的文章，这样也许合理？笑）。现在我们已能大致具备了让Shor算法工作起来的能力，除了一点，为何特征频率的倒数就是我们所求的指数p。</p><p>事实上，当完成对下路的观测的时候，我们可以看到的结果就是mod N的余数，举个例子余了 f ，而经由“信息反馈”上路留下的01串 x 就一定满足 g^x mod N = f（为什么呢，请学习 function evaluation）剩下的“波”或者说叠加态里其他的成分在相位作用下彼此相消了，他们的概率贡献给了剩下的波形。问题是如何利用好上路这些同余的串。</p><p>通过基础数学的知识，我们知道 ：任意元素乘除环上的单位元得到本身，所以假如上路一堆01串同余，那么他们就应该相差单位元的整数倍（表现出某种周期性），找到这里的”最小间隔“就找到了”单位元“。找到单位元基本就可以宣布成功了，因为单位元意味着<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mi>i</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>N</mi><mtext> </mtext><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g^i mod N =1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0191em;vertical-align:-0.1944em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span><span class="mord"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord"> </span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mord"> </span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span></span>； 熟悉的形式，这单位元（周期）就是我们渴望的p了。至于周期是频率的倒数自不必提，联系经典的傅里叶变换，量子傅里叶变换就有理由能从01串的叠加中解出特征频率。</p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">🤔</div><p><b>量子傅里叶变换和哈达玛门</b></p><p>哈达玛们和量子傅里叶变换属于最重要的一批量子门。他们最常见的用途就是放在量子路的开头，把确定态（n个基态|0&gt;）的输入变成所有长为n的01串的等概率叠加，相当于是量子叠加的发生器。至于当他们作用在全低态（|0&gt;）输入上的时候，效果是一样的（输出等概率叠加），其他时候略有不同。</p></div><p>For those interested ， 哈达玛门和量子傅里叶变换的效果可以用以下数学形式表示</p><p>哈达玛门</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo>&gt;</mo><mtext> </mtext><mo>−</mo><mo>&gt;</mo><mtext> </mtext><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi></mrow></msup><mo>∗</mo><msub><mi mathvariant="normal">Σ</mi><mi>y</mi></msub><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>x</mi><mi>y</mi></mrow></msup><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">|x&gt; -&gt; 1*2^{-1/n}*\Sigma_y(-1)^{xy}*|y&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord"> </span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord"> 1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.888em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1/</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&gt;</span></span></span></span></span></p><p>量子傅里叶变换</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mo>&gt;</mo><mtext> </mtext><mo>−</mo><mo>&gt;</mo><mtext> </mtext><mn>1</mn><mo>∗</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi></mrow></msup><mo>∗</mo><msub><mi mathvariant="normal">Σ</mi><mi>y</mi></msub><msup><mi>e</mi><mrow><mn>2</mn><mi>π</mi><mi>i</mi><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>n</mi></msup><mo>∗</mo><mi>x</mi><mi>y</mi></mrow></msup><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">|x&gt; -&gt; 1*2^{-1/n}*\Sigma_ye^{2\pi i/2^n*xy}*|y&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em"></span><span class="mord"> </span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord"> 1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.888em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1/</span><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1.1741em;vertical-align:-0.2861em"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">πi</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385em"><span style="top:-2.931em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mbin mtight">∗</span><span class="mord mathnormal mtight">x</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">y</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&gt;</span></span></span></span></span></p><p>你可以尝试验证最后一个傅里叶门可以求出特征频率</p><p>至此我们已经解出了指数p，接下来只要重复实验去碰37.5%的运气，然后反解原问题。</p><p>还有个剩下的问题是Shor算法的时间代价如何，只要跑一次量子路就解得一个p所以这部分的时间代价就是单次量子路的时间代价。而由于我们对量子路的效率做了理想化处理所以这里的代价是O（1），或者当你研究量子门的具体结构也可以认为是O（logN），不论怎样都是多项式时间。</p><p>就这样我们证明了只要足够实力实现上图的量子路，我们就真得能在多项式时间解决IFP问题，量子算法就把经典算法侮辱，把老加密轰散啊。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="量子计算的思路及表现场景">量子计算的思路及表现场景<a href="#量子计算的思路及表现场景" class="hash-link" aria-label="量子计算的思路及表现场景的直接链接" title="量子计算的思路及表现场景的直接链接">​</a></h2><p>现在我们已完整地看完了Shor算法，无论是其经典部分还是量子部分，我们可以尝试总结一下目前利用量子计算的思路。</p><ul><li>将原问题向适合量子计算的方向靠</li><li>利用叠加和量子门将概率向我们期望的结果偏向</li><li>利用重复实验以及反解之类的手段由量子实验的结果得到原问题的解</li></ul><p>于是就要问，何种场景比较适合量子计算呢，换个问法，量子计算擅长解决何种问题？</p><p>这也是一个贯穿量子计算始终的问题，自从20世纪末量子计算问世，很多研究该领域的学者都尝试回答过这个问题。而大家的共识就是<b>量子计算有尚未发掘的潜力</b>。</p><p>一开始，大家只是用量子计算处理经典计算机已经可以处理的问题，并对比他们的效率。在一些问题上，量子算法表现出优于传统算法的特性。比如&quot;Deutsch&#x27;s algorithm&quot; &quot;Bernstein-Vazirani algorithm&quot;都使得传统 O（n）的问题变得可以 O（1）解决（当然，这假设了有完美的量子元件和计算条件）。随后出现的Shor算法更是化不可能为可能，将经典指数级问题用多项式时间解决。再后来，优化过的&quot;quantum teleportation&quot;也被视为重要突破。</p><p>现在来回答那个问题，如果要表现量子计算最大的特色，那量子计算就擅长挑战<b>经典问题不能或者很难解决的问题</b>。当一些问题在经典范畴里难以进展时，不妨尝试一些量子思路，而且，万一成功了就是不得了的发现。量子计算就给人一种化不可能为可能的自信，以及一种挖宝捡漏的兴奋。</p><p>事实上，量子计算还非常具有发展潜力，许多研究和发展都处在初级阶段，不经意作出重要发现完全有可能。而且，量子计算面对的都是一些关键问题（比如NP问题），算法上的小小进展和可能会震动整个社会，属于是这辈子没白活的级别。（是否吸引到你去了解一下量子计算了）</p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">😅</div><p><b>是否可以用经典计算机模拟量子计算机</b></p><p>既然量子计算机如此牛大，而现在又没有成熟的现实实现，是由可以用已经成熟的经典计算机模拟量子计算机的工作，比如去破解几张银行卡之类的。</p><p>答案是不行，这中间有巨大的<b>信息量</b>的鸿沟，就用量子比特为例子，单个量子比特需要两个参数来描述其状态，n个量子比特就需要2*n个，这和经典计算机描述n个比特的参数多了一倍，但是并不致命，致命的是量子纠缠的问题。我们知道，物理角度讲，处于纠缠中的粒子系统无法单独描述其中一部分的状态。换句话说，只有在没纠缠的情况下才能一个一个描述Qubit的状态，而当所有Qubit完全纠缠起来，就需要2^n个参数来描述其状态（事实上，就是所有长为n的01串“加权”的结果，正好2^n个参数）</p><p>所以，当量子算法无法避开纠缠甚至要利用纠缠的时候经典计算机就立刻仆街啊。</p></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="量子计算应用的开放性例子">量子计算应用的开放性例子<a href="#量子计算应用的开放性例子" class="hash-link" aria-label="量子计算应用的开放性例子的直接链接" title="量子计算应用的开放性例子的直接链接">​</a></h2><p>以下的例子都处于未定状态，拥有惊世智慧的你完全可以尝试顺着他们的思路去研究，说不定可以搅出惊天发明！</p><p>讲点个人感受，要说刚刚了解量子计算时什么东西最吸引我，那就是那个&quot;哈达玛门&quot;，回顾一下，把n个全基态的量子比特输给H门，输出会是所有长为n的01串的等概率叠加。再联系上NP完全的布尔可满足性问题，很难让人不激动，这两者的特征实在太相似，要知道布尔可满足的经典解法就是穷举所有可能解，也就是一一尝试长为n的01串，量子路就可以同时尝试所有可能解，唯一的困难就是如何引导概率偏向对的解（残念，至今没听说布尔可满足问题被解出来，所以估计这概率操控没那么简单）。</p><p>凡是这种需要“批量尝试”的问题和量子计算向性都很不错，因为叠加态的量子比特就可以一次完成所有可能的计算，当然从叠加中得到需要的解又是另一个话题了，了不起的量子算法大多是成功地做到了引导概率的一步，而从Shor算法的例子中已经能感到，这种“引导”完成之后可能很直观但是绝对不好想。</p><div class="callout callout-bg-2 callout-border-2"><div class="callout-emoji">🤔</div><p><b>题外话</b></p><p>说起来，这种“难以设计但是易于理解”的现象也可以和NP挂钩，假如NP=P就很可能有这样的算法，它可以做到只要“能理解”就“能设计”。NP对P真的是一个覆盖范围巨大的问题</p></div><p>上面这个H门的例子背后其实是量子叠加和干涉的特性，基于同样的特性我们再举一例。这次是关于神经网络的例子。</p><p>利用反向传播更新权重这估计都听说过，但是在更新时直接消灭或者激活一些神经元估计就没什么同学认真想过了。如果网络开得太大就会浪费计算资源，过密的网络更是有过拟合的风险，所以杀一些神经元反而是有益的（某种程度上还可以扯到仿脑），这估计能达成共识。不过问题就是如何去杀，杀哪些。</p><p>最“有理有据”的想法是按照“贡献”来判断一个神经元还有没有活着的价值，假如一个神经元在与不在对决策影响微乎其微那么就杀杀杀杀，反之，假如神经元存在与否严重影响了决策那就不能删掉它。于是问题转移到了如何计算重要性上，注意到，要完整算出这种”贡献“需要大量“反事实”的计算，在经典情形里假如不用一些近似下位替代，计算的代价就无法接受。而若用量子的眼光去看，我们随手就生成所有可能的01串吔，若把0视作神经元不存在1视作存在，然后利用叠加同时计算出所有情况下的输出（然后用一些我还没想出来的妙手引导概率），似乎就有机会很方便地计算出最优的开放向量。当这样一个网络被设计出来，它的效率就没有东西能够阻挡，更多奇妙变形收附属好处更是给你惊喜啊</p><p>”叠加“告一段落，文章最后再介绍几个“纠缠”相关的方向。</p><p>说实在的，纠缠存在感最强的时候就是给好端端的干涉实验捣乱，现实中量子计算机发展缓慢有个原因就是和环境纠缠太严重；不过，也有很多非常重要的理论和应用基于纠缠。两个粒子一旦纠缠起来无论把他们隔开多远都可以“互相感应似的”做出反应。想象两个人各拿一个纠缠的粒子来到地球两头，当其中一人观测了手头的量子使其变成确定态时，地球另一端的人立即会得到相同的反应，量子纠缠就能做到如此。利用这样的基本原理，一种叫“quantum teleportation”的技术可以极快地传输信息。这是纠缠在通信上的作用。</p><p>除此之外，纠缠这种私密而准确的信息交流非常适合拿来做加密，将量子计算和密码学结合也是非常有意思的话题。</p><p>还是那个说话，量子计算还不成熟，还在发展，所以没必要将它的应用局限于这些既有领域。发挥量子的魅力，不论什么奇怪领域都可以尝试融合量子的力量，说不定下一个大奖就是你的作品</p><p>欢迎各位补充想法到开放性那节去，希望能多少激起对量子计算的兴趣😀</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/软件工程技能树/进阶技术/量子计算/量子计算.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/cs-engineering/软件工程技能树/进阶技术/GUI开发Qt/GUI开发：Qt"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">GUI开发：Qt</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/cs-engineering/软件工程技能树/进阶技术/量子计算/量子信息基础/量子信息基础"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">量子信息基础</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#spoiler" class="table-of-contents__link toc-highlight">Spoiler</a></li><li><a href="#shor-算法" class="table-of-contents__link toc-highlight">Shor 算法</a><ul><li><a href="#经典部分" class="table-of-contents__link toc-highlight">经典部分</a></li><li><a href="#量子部分" class="table-of-contents__link toc-highlight">量子部分</a></li></ul></li><li><a href="#量子计算的思路及表现场景" class="table-of-contents__link toc-highlight">量子计算的思路及表现场景</a></li><li><a href="#量子计算应用的开放性例子" class="table-of-contents__link toc-highlight">量子计算应用的开放性例子</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cs-engineering/docs/intro">Tutoria</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/cs-engineering/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/zjuxlab/cs-engineering" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 浙江大学启真交叉学科创新创业实验室, Inc.</div></div></div></footer></div>
<script src="/cs-engineering/assets/js/runtime~main.ff1670aa.js"></script>
<script src="/cs-engineering/assets/js/main.c272b5bd.js"></script>
</body>
</html>